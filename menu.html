<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DigiKhana Menu</title>
    <link rel="icon" type="image/png"
        href="https://digikhana-production.s3.ap-south-1.amazonaws.com/assets/common/DigikhanaLogo.png">

    <!-- Fonts & Tailwind -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&family=Quicksand:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Plus Jakarta Sans"', 'sans-serif'],
                        display: ['"Quicksand"', 'sans-serif'],
                    },
                    colors: {
                        orange: {
                            50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74',
                            400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c',
                            800: '#9a3412', 900: '#7c2d12',
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #f9fafb;
            -webkit-tap-highlight-color: transparent;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.6);
        }

        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .animate-slide-up {
            animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
            }

            to {
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Smooth image loading */
        img {
            transition: opacity 0.3s ease-in-out;
        }

        img[loading] {
            opacity: 0;
        }

        img.loaded {
            opacity: 1;
        }
    </style>
</head>

<body
    class="bg-gray-50 text-gray-800 font-sans min-h-screen pb-28 relative overflow-x-hidden selection:bg-orange-100 selection:text-orange-900">

    <!-- Background -->
    <div class="fixed inset-0 pointer-events-none z-0 overflow-hidden">
        <div class="absolute -top-[10%] -left-[10%] w-[50%] h-[50%] bg-orange-200/20 rounded-full blur-[100px]"></div>
        <div class="absolute top-[20%] -right-[10%] w-[40%] h-[40%] bg-blue-200/10 rounded-full blur-[100px]"></div>
    </div>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 relative z-10">

        <!-- Header -->
        <header id="restaurant-header" class="text-center mb-8 animate-fade-in">
            <!-- Dynamic Content -->
            <div class="h-24 flex items-center justify-center">
                <div class="w-8 h-8 border-2 border-orange-500 rounded-full border-t-transparent animate-spin"></div>
            </div>
        </header>

        <!-- Search Bar -->
        <div class="sticky top-0 z-40 bg-gray-50/95 backdrop-blur-md pb-4 pt-2 -mx-4 px-4 sm:px-6 transition-all duration-300 shadow-sm"
            id="search-bar-container">
            <div class="relative max-w-lg mx-auto">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none"
                        viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                </div>
                <input type="text" id="search-input"
                    class="block w-full pl-10 pr-10 py-3 border-none rounded-2xl leading-5 bg-white text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-orange-500 shadow-md shadow-gray-100/50"
                    placeholder="Search for dishes..." oninput="handleSearch(this.value)" />

                <!-- Clear Button -->
                <button id="clear-search-btn" onclick="clearSearch()"
                    class="absolute inset-y-0 right-0 pr-3 flex items-center hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 hover:text-gray-600"
                        viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd"
                            d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                            clip-rule="evenodd" />
                    </svg>
                </button>
            </div>

            <!-- Category Chips -->
            <div class="flex items-center gap-2 overflow-x-auto hide-scrollbar mt-3 pb-1 max-w-lg mx-auto"
                id="category-chips">
                <!-- Injected dynamically -->
            </div>
        </div>

        <!-- Cart Summary (Top of Menu) -->
        <div id="cart-summary-top" class="hidden mt-6 mb-6">
            <div class="bg-white rounded-2xl shadow-md border border-gray-100 p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="font-bold text-gray-900 text-lg flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-orange-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z" />
                        </svg>
                        Cart
                    </h3>
                    <button onclick="openCart()" class="text-sm font-semibold text-orange-600 hover:text-orange-700">
                        View All
                    </button>
                </div>
                <div id="cart-summary-items" class="space-y-2">
                    <!-- Cart items will be injected here -->
                </div>
                <!-- Total Amount -->
                <div id="cart-summary-total" class="hidden mt-4 pt-4 border-t border-gray-200 flex items-center justify-between">
                    <span class="font-bold text-gray-700 text-sm">Total:</span>
                    <span class="font-bold text-orange-600 text-lg" id="cart-summary-total-amount">‚Çπ0</span>
                </div>
            </div>
        </div>

        <!-- Items Grid -->
        <div id="items-container" class="space-y-10 mt-6 min-h-[50vh]">
            <div class="flex flex-col items-center justify-center py-20">
                <div class="w-10 h-10 border-4 border-orange-200 border-t-orange-500 rounded-full animate-spin"></div>
                <p class="text-gray-500 mt-4 font-medium animate-pulse">Loading menu...</p>
            </div>
        </div>

    </div>

    <!-- Floating Table Status (If Active) -->
    <!-- Status Banner (Removed - buttons moved to cart modal) -->


    <!-- Cart Floating Bar -->
    <div id="cart-bar" onclick="openCart()"
        class="hidden fixed bottom-6 left-1/2 transform -translate-x-1/2 w-[90%] max-w-md glass-panel bg-gray-900/95 text-white shadow-2xl rounded-full p-2 z-50 cursor-pointer transition-all duration-200 hover:scale-[1.02] active:scale-[0.98] ring-1 ring-white/20 flex items-center justify-between pr-5 pl-2 backdrop-blur-xl">
        <div class="flex items-center gap-3">
            <div
                class="bg-orange-500 text-white w-10 h-10 rounded-full flex items-center justify-center font-bold text-sm shadow-lg shadow-orange-500/30 cart-count transition-transform transform scale-100">
                0</div>
            <div class="flex flex-col">
                <span
                    class="text-[10px] font-bold text-gray-400 uppercase tracking-wider leading-none mb-0.5 cart-label">Total</span>
                <span class="text-lg font-bold text-white leading-none cart-total">‚Çπ0</span>
                <span id="cart-sync-indicator" class="text-[9px] text-gray-300 mt-1 hidden">Syncing...</span>
            </div>
        </div>
        <div class="flex items-center gap-2 font-bold text-sm text-white">
            <span class="cart-action-text">View Cart</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
        </div>
    </div>

    <!-- Cart Modal -->
    <div id="cart-modal"
        class="fixed inset-0 z-[60] hidden flex flex-col justify-end md:justify-center md:items-center pointer-events-none">
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm pointer-events-auto transition-opacity duration-300"
            onclick="closeCart()"></div>
        <div
            class="relative w-full md:w-[95%] md:max-w-md bg-white rounded-t-3xl md:rounded-3xl shadow-2xl flex flex-col max-h-[90vh] animate-slide-up transform transition-transform overflow-hidden pointer-events-auto">

            <!-- Header -->
            <div class="p-5 border-b border-gray-100 bg-white z-10">
                <div class="flex items-center justify-between mb-3">
                    <div>
                        <h2 class="text-2xl font-bold text-gray-900 font-display">Your Order</h2>

                    </div>
                    <button onclick="closeCart()" class="p-2 bg-gray-50 rounded-full hover:bg-gray-100 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-500" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Content -->
            <div class="flex-1 overflow-y-auto p-5 custom-scrollbar">

                <!-- Existing Table Order (Read Only) -->
                <div id="existing-order-section"
                    class="hidden mb-6 border border-green-100 bg-green-50/50 rounded-2xl p-4">
                    <h3 class="font-bold text-green-800 text-sm uppercase tracking-wide mb-3 flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        Already Ordered
                    </h3>
                    <div id="existing-items-list" class="space-y-2 text-sm text-gray-700"></div>
                </div>

                <!-- New Items -->
                <div id="cart-items-list" class="space-y-4"></div>

                <!-- Guest Form -->
                <div class="pt-6 mt-6 border-t border-gray-100 space-y-4">
                    <h3 class="font-bold text-gray-900 text-sm uppercase tracking-wide">Guest Details <span
                            class="font-normal text-gray-400 capitalize">(Optional)</span></h3>
                    <input type="text" id="guest-name" placeholder="Your Name"
                        class="w-full px-4 py-3 rounded-xl bg-gray-50 border-none focus:ring-2 focus:ring-orange-200 text-gray-900 placeholder-gray-400 font-medium text-sm">
                    <input type="tel" id="guest-phone" placeholder="Phone Number"
                        class="w-full px-4 py-3 rounded-xl bg-gray-50 border-none focus:ring-2 focus:ring-orange-200 text-gray-900 placeholder-gray-400 font-medium text-sm">
                </div>
            </div>

            <!-- Footer -->
            <div class="p-5 border-t border-gray-100 bg-gray-50 rounded-b-3xl space-y-3">
                <!-- Cancel Request Button (shown when pending request exists) -->
                <button id="cancel-req-btn" onclick="cancelPendingRequest()"
                    class="hidden w-full py-3 bg-red-50 text-red-700 rounded-xl font-bold text-base border-2 border-red-200 shadow-sm hover:bg-red-100 active:scale-[0.98] transition-all">
                    Cancel Request
                </button>
                
                <button id="place-order-btn" onclick="submitOrder()"
                    class="w-full py-3.5 bg-gray-900 text-white rounded-xl font-bold text-lg shadow-lg shadow-gray-900/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2 px-6">
                    <span>Checkout</span>
                    <svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Order Config Dialog -->
    <div id="confirm-dialog" class="fixed inset-0 z-[80] hidden items-center justify-center p-4">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-sm animate-fade-in"></div>
        <div class="relative bg-white rounded-3xl p-6 w-full max-w-sm shadow-2xl animate-slide-up text-center">
            <div
                class="w-16 h-16 bg-green-100 text-green-600 rounded-full flex items-center justify-center mx-auto mb-4 text-3xl">
                üéâ</div>
            <h3 class="text-xl font-bold text-gray-900 mb-2">Request Sent!</h3>
            <p class="text-gray-500 text-sm mb-6">Staff will review your request shortly. You can add more items to this
                order anytime.</p>
            <button onclick="closeConfirmDialog()" class="w-full py-3 bg-gray-900 text-white rounded-xl font-bold">Okay,
                Got it</button>
        </div>
    </div>

    <!-- Checkout Reminder Popup -->
    <div id="checkout-reminder-popup" class="fixed inset-0 z-[90] hidden items-center justify-center p-4">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-sm animate-fade-in"></div>
        <div class="relative bg-white rounded-3xl p-6 w-full max-w-sm shadow-2xl animate-slide-up">
            <div class="text-center mb-4">
                <div class="w-16 h-16 bg-orange-100 text-orange-600 rounded-full flex items-center justify-center mx-auto mb-4 text-3xl">
                    ‚è∞
                </div>
                <h3 class="text-xl font-bold text-gray-900 mb-2">Items in Your Cart</h3>
                <p class="text-gray-500 text-sm">You have unsaved items. Would you like to send your request now?</p>
            </div>
            <div class="flex gap-3 mt-6">
                <button onclick="dismissCheckoutReminder()" 
                    class="flex-1 py-3 bg-gray-100 text-gray-700 rounded-xl font-bold hover:bg-gray-200 transition-colors">
                    Dismiss
                </button>
                <button onclick="openCartFromReminder()" 
                    class="flex-1 py-3 bg-gray-900 text-white rounded-xl font-bold hover:bg-gray-800 transition-colors">
                    Checkout
                </button>
            </div>
        </div>
    </div>

    <!-- Pickup Identity Gate (Full-page overlay for pickup QR) -->
    <div id="pickup-gate-overlay" class="fixed inset-0 z-[95] hidden items-center justify-center p-4 bg-black/70 backdrop-blur-sm">
        <div class="relative bg-white rounded-3xl w-full max-w-sm shadow-2xl p-6">
            <div class="text-center mb-4">
                <div class="w-16 h-16 bg-orange-100 text-orange-600 rounded-full flex items-center justify-center mx-auto mb-4 text-3xl">
                    üõçÔ∏è
                </div>
                <h3 class="text-xl font-bold text-gray-900 mb-1">Pickup Order</h3>
                <p class="text-gray-500 text-sm">
                    Enter your phone number to view your orders, status and pay (same as table number for dine-in).
                </p>
            </div>
            <div class="space-y-4 mt-4">
                <div>
                    <label class="block text-sm font-semibold text-gray-700 mb-1">
                        Phone Number <span class="text-red-500">*</span>
                    </label>
                    <input
                        id="pickup-gate-phone"
                        type="tel"
                        class="w-full px-4 py-3 rounded-xl bg-gray-50 border border-gray-200 focus:ring-2 focus:ring-orange-500 focus:border-orange-500 text-gray-900 placeholder-gray-400 text-sm"
                        placeholder="Enter your phone number"
                    />
                </div>
                <div>
                    <label class="block text-sm font-semibold text-gray-700 mb-1">
                        Name <span class="text-red-500">*</span>
                    </label>
                    <input
                        id="pickup-gate-name"
                        type="text"
                        class="w-full px-4 py-3 rounded-xl bg-gray-50 border border-gray-200 focus:ring-2 focus:ring-orange-500 focus:border-orange-500 text-gray-900 placeholder-gray-400 text-sm"
                        placeholder="Enter your name"
                    />
                </div>
                <p id="pickup-gate-error" class="text-xs text-red-500 min-h-[1.25rem]"></p>
                <button
                    onclick="handlePickupGateSubmit()"
                    class="w-full py-3.5 bg-gray-900 text-white rounded-xl font-bold text-base shadow-lg shadow-gray-900/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2"
                >
                    Continue
                </button>
            </div>
        </div>
    </div>


    <script>
        // State
        const urlParams = new URLSearchParams(window.location.search);
        const state = {
            tenantId: urlParams.get('tenant_id'),
            tableId: urlParams.get('table_id') || urlParams.get('room_id'),
            hallId: urlParams.get('hall_id') || (urlParams.get('room_id') ? 'ROOM_SERVICE' : null),
            items: [],
            itemsMap: {},
            cart: {}, // { code: { qty: 1, item: ... } }
            existingOrder: null,
            pendingRequest: null, // NEW: Store pending request
            isEditingPendingRequest: false, // Flag to prevent overwriting user edits
            cartModifiedFromPending: false, // Track if cart has been modified from original pending request
            lastCartUpdateTime: null, // Track when cart was last modified for popup
            checkoutPopupDismissed: false, // Track if user dismissed the checkout popup
            lastUserAction: null, // Track last user interaction time for polling pause
            isSyncing: false, // Show syncing indicator when talking to server
            flowStatus: 'idle', // 'idle' | 'editing' | 'pending' | 'approved'
            filter: { category: 'All', search: '' },
            settings: {},
            // Pickup specific (phone = identifier, like table_id+hall_id for dine-in)
            isPickupMode: false,
            guestPhone: "",
            guestName: "",
            isPickupInitialized: false,
            pickupPollingIntervalId: null, // setInterval for polling status by phone
        };

        // Initialize pickup flags from URL (separate QR for pickup)
        (function initPickupFlags() {
            const pickupFlag = urlParams.get('pickup');
            if (pickupFlag && (pickupFlag === 'true' || pickupFlag === '1')) {
                state.isPickupMode = true;
            }
        })();

        function markUserActive() {
            state.lastUserAction = Date.now();
        }

        // ... Configuration ... (Same as before)
        const IS_LOCAL = true;
        const PROD_LAMBDA_URL = "https://ydhettu7l6.execute-api.ap-south-1.amazonaws.com/production/api/guest/order/request";
        const LAMBDA_URL = IS_LOCAL ? 'http://localhost:3001/api/guest/lambda' : PROD_LAMBDA_URL;

        // ... Initialization ... 

        function renderPickupGateIfNeeded() {
            const overlay = document.getElementById('pickup-gate-overlay');
            if (!overlay) return;

            // Only show gate in pickup mode when identity not yet initialized
            if (state.isPickupMode && !state.isPickupInitialized) {
                overlay.classList.remove('hidden');
                overlay.classList.add('flex');

                // Pre-fill inputs if we already have values
                const phoneInput = document.getElementById('pickup-gate-phone');
                const nameInput = document.getElementById('pickup-gate-name');
                if (phoneInput && state.guestPhone) phoneInput.value = state.guestPhone;
                if (nameInput && state.guestName) nameInput.value = state.guestName;
            } else {
                overlay.classList.add('hidden');
                overlay.classList.remove('flex');
            }
        }

        function normalizeTenDigitPhone(input) {
            const digits = String(input || "").replace(/\D/g, "");
            return digits.length === 10 ? digits : null;
        }

        window.handlePickupGateSubmit = async () => {
            const phoneInput = document.getElementById('pickup-gate-phone');
            const nameInput = document.getElementById('pickup-gate-name');
            const errorEl = document.getElementById('pickup-gate-error');
            if (!phoneInput || !nameInput || !errorEl) return;

            const phone = (phoneInput.value || '').trim();
            const name = (nameInput.value || '').trim();

            if (!phone || !name) {
                errorEl.textContent = 'Phone number and name are required for pickup orders.';
                return;
            }

            const normalizedPhone = normalizeTenDigitPhone(phone);
            if (!normalizedPhone) {
                errorEl.textContent = 'Please enter a valid 10-digit phone number.';
                return;
            }

            errorEl.textContent = '';
            state.guestPhone = normalizedPhone;
            state.guestName = name;
            state.isPickupInitialized = true;

            // Sync into cart guest details inputs if they exist
            const guestNameInput = document.getElementById('guest-name');
            const guestPhoneInput = document.getElementById('guest-phone');
            if (guestNameInput) guestNameInput.value = state.guestName;
            if (guestPhoneInput) guestPhoneInput.value = state.guestPhone;
            phoneInput.value = state.guestPhone;

            renderPickupGateIfNeeded();
            // Initial fetch by phone (same as checkTableStatus for dine-in)
            await checkPickupStatus(true);
            // Poll and sync status/details every 5s (same as dine-in)
            if (state.pickupPollingIntervalId) clearInterval(state.pickupPollingIntervalId);
            state.pickupPollingIntervalId = setInterval(() => checkPickupStatus(false), 5000);
        };

        async function init() {
            if (!state.tenantId) {
                document.body.innerHTML = '<div class="p-10 text-center">Missing Tenant ID</div>';
                return;
            }

            try {
                // 1. Fetch Guest Settings (via Lambda/Sim)
                // Appending path for Proxy: /settings
                const settingsRes = await axios.get(`${LAMBDA_URL}/settings?tenant_id=${state.tenantId}`);
                state.settings = settingsRes.data.settings;
                renderHeader();

                // 2. Fetch Items (Default GET to Lambda/Sim)
                const menuRes = await axios.get(`${LAMBDA_URL}?tenant_id=${state.tenantId}`);
                state.items = menuRes.data.items || menuRes.data; // Handle {items: []} or raw []
                state.itemsMap = state.items.reduce((acc, item) => { acc[item.item_code] = item; return acc; }, {});
                

                renderMenu();

                // 3. Initial Status Check
                if (state.isPickupMode) {
                    // Show full-page gate; status will be fetched after identity is submitted
                    renderPickupGateIfNeeded();
                    updateCartSummaryTop();
                } else if (state.tableId && state.hallId) {
                    await checkTableStatus(true);
                    // Poll status every 5s
                    setInterval(() => checkTableStatus(false), 5000);
                } else {
                    // Update cart summary even if no table status check
                    updateCartSummaryTop();
                }

            } catch (err) {
                console.error(err);
                document.getElementById('items-container').innerHTML =
                    '<div class="text-center py-20 text-red-500">Failed to load menu. Please scan again.</div>';
            }
        }

        function renderHeader() {
            const header = document.getElementById('restaurant-header');
            const { restaurant_name, restaurant_address, phone_no, restaurant_logo } = state.settings;
            const hasLogo = restaurant_logo && String(restaurant_logo).trim() !== '';

            // Format address handling string vs object
            let formattedAddress = "";
            if (restaurant_address) {
                if (typeof restaurant_address === 'string') {
                    formattedAddress = restaurant_address;
                } else if (typeof restaurant_address === 'object') {
                    formattedAddress = [
                        restaurant_address.address_line_1,
                        restaurant_address.address_line_2,
                        restaurant_address.city,
                        restaurant_address.pincode
                    ].filter(part => part && String(part).trim() !== '').join(', ');
                }
            }

            const logoBlock = hasLogo
                ? `<div class="inline-flex items-center justify-center w-14 h-14 rounded-2xl shadow-sm mb-4 bg-white overflow-hidden"><img src="${String(restaurant_logo).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}" alt="" class="w-full h-full object-contain" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" /><span class="inline-flex items-center justify-center w-full h-full text-2xl" style="display: none;">üçΩÔ∏è</span></div>`
                : `<div class="inline-flex items-center justify-center w-14 h-14 bg-white rounded-2xl shadow-sm mb-4 text-2xl">üçΩÔ∏è</div>`;

            header.innerHTML = `
                <div class="h-24 flex items-center justify-center">${logoBlock}</div>
                <h1 class="text-2xl md:text-3xl font-bold text-gray-900 mb-1 font-display tracking-tight">${restaurant_name}</h1>
                <p class="text-gray-500 font-medium text-xs md:text-sm tracking-wide uppercase max-w-md mx-auto leading-relaxed">
                    ${formattedAddress} ${phone_no ? ' ‚Ä¢ ' + phone_no : ''}
                </p>
                <div class="max-w-md mx-auto">
                    <div class="text-[10px] md:text-xs text-gray-400 font-medium mt-1 mb-2 text-center tracking-wide">
                        Powered by DigiKhana
                    </div>
                </div>
            `;
        }

        // --- Updated Check Table Status ---
        async function checkTableStatus(force = false) {
            // Skip polling if user was active in the last 10 seconds, unless forced
            if (!force && state.lastUserAction && Date.now() - state.lastUserAction < 10000) {
                return;
            }

            // Show syncing indicator while we talk to the server
            state.isSyncing = true;
            updateCartBarUI();

            try {
                const res = await axios.get(`${LAMBDA_URL}/table/status`, {
                    params: { tenant_id: state.tenantId, table_id: state.tableId, hall_id: state.hallId }
                });

                if (res.data.success) {
                    const prevPendingId = state.pendingRequest ? state.pendingRequest.request_id : null;

                    // 1. Pending Request Handling
                    const hasPendingRequestInResponse = res.data.active_order && res.data.active_order.pending_request;
                    const hasActiveOrderItems = res.data.active_order && res.data.active_order.items && res.data.active_order.items.length > 0;
                    
                    // Check if pending request was approved (had pending before, now it's gone and order exists)
                    const wasPendingApproved = prevPendingId && !hasPendingRequestInResponse && hasActiveOrderItems;
                    
                    if (hasPendingRequestInResponse) {
                        // There's still a pending request
                        const newPendingId = res.data.active_order.pending_request.request_id;
                        const isNewPendingRequest = !state.pendingRequest || state.pendingRequest.request_id !== newPendingId;
                        
                        if (!state.isEditingPendingRequest && !state.cartModifiedFromPending) {
                            // Only update cart if this is a new pending request or cart hasn't been modified
                            if (isNewPendingRequest || !state.cartModifiedFromPending) {
                                state.pendingRequest = res.data.active_order.pending_request;
                                
                                // Populate cart with pending items to show quantity buttons
                                state.cart = {};
                                state.pendingRequest.items.forEach(pi => {
                                    const originalItem = state.itemsMap[pi.item_code] || pi;
                                    state.cart[pi.item_code] = {
                                        qty: pi.quantity,
                                        item: originalItem
                                    };
                                });
                                
                                // Reset modification flag when we sync from server
                                state.cartModifiedFromPending = false;
                                
                                // Update UI to reflect pending quantities
                                updateCartBarUI();
                                updateMenuQuantitiesOnly();
                            } else {
                                // Just update the pendingRequest object, don't touch cart
                                state.pendingRequest = res.data.active_order.pending_request;
                            }
                        } else {
                            // User is editing - just update the pendingRequest object, don't touch cart
                            state.pendingRequest = res.data.active_order.pending_request;
                        }
                    } else if (wasPendingApproved || (!hasPendingRequestInResponse && prevPendingId)) {
                        // Pending request was approved or removed - clear it
                        // At this point all previously pending items are now part of the approved order,
                        // so the local cart should be reset to avoid treating them as "new" items.
                        if (Object.keys(state.cart).length > 0) {
                            state.cart = {};
                            updateCartBarUI();
                            updateMenuQuantitiesOnly();
                            updateCartSummaryTop();
                        }
                        
                        // Clear pending request state
                        state.pendingRequest = null;
                        state.isEditingPendingRequest = false;
                        state.cartModifiedFromPending = false;
                    }

                    // 2. Active Order (Confirmed / Billed)
                    // If search returns active_order with items or bill details, that's the live/billed order
                    if (res.data.active_order && (res.data.active_order.items || res.data.active_order.bill_details)) {
                        state.existingOrder = res.data.active_order;
                    } else {
                        state.existingOrder = null;
                    }

                    // Keep a single high-level status value in sync
                    updateFlowStatus();

                    // 3. Update UI Components

                    // If the modal is OPEN, refresh it effectively immediately
                    if (!document.getElementById('cart-modal').classList.contains('hidden')) {
                        renderCartModalItems();
                    }

                    updateStatusUI();
                    
                    // Update cart bar to show when approved order exists
                    updateCartBarUI();
                    
                    // Update cancel button in cart modal even when closed
                    const cancelBtn = document.getElementById('cancel-req-btn');
                    if (cancelBtn) {
                        if (state.pendingRequest) {
                            cancelBtn.classList.remove('hidden');
                        } else {
                            cancelBtn.classList.add('hidden');
                        }
                    }
                }
            } catch (e) {
                console.log("Table status check failed silently", e);
            } finally {
                state.isSyncing = false;
                updateCartBarUI();
            }
        }

        function updateStatusUI() {
            // Status banner removed - cancel button is now in cart modal footer
            // Update cancel button visibility in cart modal footer
            const cancelBtn = document.getElementById('cancel-req-btn');
            if (cancelBtn) {
                if (state.pendingRequest) {
                    cancelBtn.classList.remove('hidden');
                } else {
                    cancelBtn.classList.add('hidden');
                }
            }
        }

        function updateFlowStatus() {
            if (state.pendingRequest) {
                if (state.isEditingPendingRequest || state.cartModifiedFromPending || Object.keys(state.cart).length > 0) {
                    state.flowStatus = 'editing';
                } else {
                    state.flowStatus = 'pending';
                }
            } else if (state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0) {
                state.flowStatus = 'approved';
            } else {
                state.flowStatus = 'idle';
            }
        }

        // --- Pickup Status (by phone) ---
        async function checkPickupStatus(force = false) {
            // Skip polling if user was active in the last 10 seconds, unless forced
            if (!force && state.lastUserAction && Date.now() - state.lastUserAction < 10000) {
                return;
            }

            if (!state.guestPhone) {
                return;
            }

            state.isSyncing = true;
            updateCartBarUI();

            try {
                const res = await axios.get(`${LAMBDA_URL}/pickup/status`, {
                    params: { tenant_id: state.tenantId, guest_phone: state.guestPhone }
                });

                if (res.data && res.data.success) {
                    const prevPendingId = state.pendingRequest ? state.pendingRequest.request_id : null;
                    const pending = res.data.pending_request || null;
                    const active = res.data.active_order || null;

                    // Pending request handling (mirror table logic but keyed by phone)
                    if (pending) {
                        const newPendingId = pending.request_id;
                        const isNewPendingRequest = !state.pendingRequest || state.pendingRequest.request_id !== newPendingId;

                        if (!state.isEditingPendingRequest && !state.cartModifiedFromPending) {
                            if (isNewPendingRequest || !state.cartModifiedFromPending) {
                                state.pendingRequest = pending;

                                // Populate cart with pending items
                                state.cart = {};
                                (pending.items || []).forEach(pi => {
                                    const originalItem = state.itemsMap[pi.item_code] || pi;
                                    state.cart[pi.item_code] = {
                                        qty: pi.quantity,
                                        item: originalItem
                                    };
                                });

                                state.cartModifiedFromPending = false;
                                updateCartBarUI();
                                updateMenuQuantitiesOnly();
                            } else {
                                state.pendingRequest = pending;
                            }
                        } else {
                            state.pendingRequest = pending;
                        }
                    } else if (!pending && prevPendingId) {
                        // Pending request was approved/removed
                        if (Object.keys(state.cart).length > 0) {
                            state.cart = {};
                            updateCartBarUI();
                            updateMenuQuantitiesOnly();
                            updateCartSummaryTop();
                        }
                        state.pendingRequest = null;
                        state.isEditingPendingRequest = false;
                        state.cartModifiedFromPending = false;
                    }

                    // Active pickup order (if any)
                    if (active && (active.items || active.bill_details)) {
                        state.existingOrder = active;
                    } else {
                        state.existingOrder = null;
                    }

                    updateFlowStatus();

                    if (!document.getElementById('cart-modal').classList.contains('hidden')) {
                        renderCartModalItems();
                    }

                    updateStatusUI();
                    updateCartBarUI();
                }
            } catch (e) {
                console.log("Pickup status check failed silently", e);
            } finally {
                state.isSyncing = false;
                updateCartBarUI();
            }
        }

        window.cancelPendingRequest = async () => {
            if (!confirm('Are you sure you want to cancel your request?')) return;

            const btn = document.getElementById('cancel-req-btn');
            if (btn) btn.innerHTML = '...';

            try {
                const res = await axios.delete(`${LAMBDA_URL}/request`, {
                    data: {
                        tenant_id: state.tenantId,
                        request_id: state.pendingRequest.request_id
                    }
                });

                if (res.data.success) {
                    // Clear pending request and cart immediately
                    state.pendingRequest = null;
                    state.isEditingPendingRequest = false;
                    state.cartModifiedFromPending = false;
                    
                    // Clear cart to remove quantity buttons (revert to "ADD" buttons)
                    state.cart = {};
                    updateFlowStatus();
                    updateCartBarUI();
                    updateMenuQuantitiesOnly();
                    
                    // Refresh status to sync with backend
                    if (state.isPickupMode) checkPickupStatus(true); else checkTableStatus(true);
                } else {
                    alert('Failed to cancel request');
                }
            } catch (e) {
                console.error(e);
                alert('Connection error');
            }
        };

        window.editPendingRequest = () => {
            if (!state.pendingRequest) return;

            // Set flag to prevent polling from overwriting edits
            state.isEditingPendingRequest = true;
            markUserActive();

            // Cart is already populated from checkTableStatus, but ensure it's synced
            // This allows user to modify quantities
            state.pendingRequest.items.forEach(pi => {
                const originalItem = state.itemsMap[pi.item_code] || pi;
                // Only update if not already in cart (preserve any user modifications)
                if (!state.cart[pi.item_code]) {
                    state.cart[pi.item_code] = {
                        qty: pi.quantity,
                        item: originalItem
                    };
                }
            });

            // Reset modification flag when entering edit mode
            state.cartModifiedFromPending = false;

            updateFlowStatus();
            updateCartBarUI();
            updateMenuQuantitiesOnly();
            openCart();
        };

        window.updateMenuQuantitiesOnly = () => {
            state.items.forEach(item => {
                const qty = state.cart[item.item_code]?.qty || 0;
                const wrapper = document.getElementById(`qty-wrapper-${item.item_code}`);
                if (wrapper) {
                    wrapper.innerHTML = getQtyButtonHTML(item.item_code, item.sold_out);
                }
            });
        };

        // --- Core Rendering (optimized) ---

        let isMenuRendered = false;

        function renderMenu(forceRebuild = false) {
            const container = document.getElementById('items-container');

            // Initial Build
            if (!isMenuRendered || forceRebuild) {
                container.innerHTML = "";

                // Grouping
                const grouped = {};
                state.items.forEach(item => {
                    const cat = item.category || 'Other';
                    if (!grouped[cat]) grouped[cat] = [];
                    grouped[cat].push(item);
                });

                // Render Groups
                Object.entries(grouped).forEach(([category, items]) => {
                    const section = document.createElement('div');
                    section.className = 'w-full scroll-mt-32';
                    section.id = `cat-${category.replace(/\s+/g, '-')}`;
                    section.dataset.category = category; // Data attribute for filtering

                    const title = document.createElement('h2');
                    title.className = 'text-xl font-bold text-gray-800 mb-4 sticky top-0 bg-gray-50/95 backdrop-blur-sm p-2 z-10 flex items-center';
                    title.innerHTML = `<span class="w-1 h-5 bg-orange-500 rounded-full mr-3"></span>${category}`;
                    section.appendChild(title);

                    const grid = document.createElement('div');
                    grid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';

                    items.forEach(item => {
                        const el = createItemCard(item);
                        grid.appendChild(el);
                    });

                    section.appendChild(grid);
                    container.appendChild(section);
                });

                renderCategories();
                isMenuRendered = true;
            }

            // Filtering (Visibility Toggle)
            const searchQuery = state.filter.search ? state.filter.search.toLowerCase() : "";
            const selectedCat = state.filter.category;

            let hasVisibleItems = false;

            // Iterate through all sections
            const sections = container.querySelectorAll('[id^="cat-"]');
            sections.forEach(section => {
                const category = section.dataset.category;
                const items = section.querySelectorAll('[id^="card-"]');
                let visibleItemsInSection = 0;

                items.forEach(card => {
                    // Extract data from custom attributes or rebuild lookup
                    // For simplicity, we can store name/cat on the card itself or lookup via ID
                    const itemCode = card.id.replace('card-', '');
                    const item = state.itemsMap[itemCode]; // Ensure we have a map

                    if (!item) return;

                    const matchSearch = !searchQuery || item.name.toLowerCase().includes(searchQuery);
                    const matchCat = selectedCat === 'All' || item.category === selectedCat;

                    if (matchSearch && matchCat) {
                        card.classList.remove('hidden');
                        visibleItemsInSection++;
                        hasVisibleItems = true;
                    } else {
                        card.classList.add('hidden');
                    }
                });

                // Hide section if no items visible
                if (visibleItemsInSection === 0) {
                    section.classList.add('hidden');
                } else {
                    section.classList.remove('hidden');
                }
            });

            // Show/Hide "No Items" msg
            let noItemsMsg = document.getElementById('no-items-msg');
            if (!hasVisibleItems) {
                if (!noItemsMsg) {
                    noItemsMsg = document.createElement('div');
                    noItemsMsg.id = 'no-items-msg';
                    noItemsMsg.className = 'text-center py-20 text-gray-400';
                    noItemsMsg.textContent = 'No items found';
                    container.appendChild(noItemsMsg);
                }
                noItemsMsg.classList.remove('hidden');
            } else if (noItemsMsg) {
                noItemsMsg.classList.add('hidden');
            }
        }

        function createItemCard(item) {
            const div = document.createElement('div');
            const isSoldOut = item.sold_out;
            const imgUrl = `https://digikhana-production.s3.amazonaws.com/item/${state.tenantId}/${item.item_code}.jpg`;

            // Using a Key for easy DOM update lookup
            div.id = `card-${item.item_code}`;
            
            // Make card clickable (except when sold out)
            if (!isSoldOut) {
                div.style.cursor = 'pointer';
                div.onclick = (e) => {
                    // Don't trigger if clicking on quantity buttons
                    if (!e.target.closest(`#qty-wrapper-${item.item_code}`)) {
                        updateCart(item.item_code, 1);
                    }
                };
            }

            div.className = `bg-white rounded-2xl p-4 shadow-sm border border-gray-100 flex gap-4 ${isSoldOut ? 'opacity-60' : 'hover:shadow-md transition-shadow'} ${!isSoldOut ? 'cursor-pointer' : ''}`;

            div.innerHTML = `
                <div class="h-24 w-24 flex-shrink-0 rounded-xl bg-gray-100 overflow-hidden relative">
                     <img src="${imgUrl}" class="w-full h-full object-cover" 
                          onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 fill=%22%23eee%22/><text x=%2250%22 y=%2250%22 font-family=%22Arial%22 font-size=%2220%22 fill=%22%23bbb%22 text-anchor=%22middle%22 dy=%22.3em%22>No Image</text></svg>'">
                     ${isSoldOut ? '<div class="absolute inset-0 bg-black/50 flex items-center justify-center text-white text-[10px] font-bold">SOLD OUT</div>' : ''}
                </div>
                <div class="flex-1 flex flex-col justify-between">
                    <div>
                        <div class="flex justify-between items-start">
                             <h3 class="font-bold text-gray-900 leading-tight mb-1 text-[15px]">${item.name}</h3>
                             ${item.is_veg === true ? '<div class="w-3 h-3 border border-green-600 flex items-center justify-center p-[1px] rounded-[2px] ml-1"><div class="w-1.5 h-1.5 bg-green-600 rounded-full"></div></div>' : (item.is_veg === false ? '<div class="w-3 h-3 border border-red-600 flex items-center justify-center p-[1px] rounded-[2px] ml-1"><div class="w-1.5 h-1.5 bg-red-600 rounded-full"></div></div>' : '')}
                        </div>
                        <p class="font-bold text-gray-900 text-sm">‚Çπ${item.price}</p>
                    </div>
                    
                    <div class="flex justify-end mt-2" id="qty-wrapper-${item.item_code}" onclick="event.stopPropagation()">
                        <!-- Injected by updateItemQtyUI -->
                        ${getQtyButtonHTML(item.item_code, isSoldOut)}
                    </div>
                </div>
            `;
            return div;
        }

        function getQtyButtonHTML(code, isSoldOut) {
            if (isSoldOut) return `<button disabled class="text-xs font-bold text-gray-400 bg-gray-100 px-3 py-1.5 rounded-lg cursor-not-allowed">Sold Out</button>`;

            const qty = state.cart[code]?.qty || 0;
            if (qty === 0) {
                // Always allow adding items
                return `<button onclick="updateCart('${code}', 1)" class="bg-orange-50 text-orange-600 font-extrabold text-xs px-5 py-2 rounded-xl shadow-sm border border-orange-100 active:bg-orange-100 uppercase tracking-wide">ADD</button>`;
            } else {
                // Always show editable quantity controls
                return `
                    <div class="flex items-center bg-gray-900 text-white rounded-lg shadow-md h-8">
                        <button onclick="updateCart('${code}', -1)" class="w-8 h-full flex items-center justify-center font-bold text-lg hover:bg-white/10 active:bg-white/20 rounded-l-lg">-</button>
                        <span class="w-6 text-center font-bold text-sm">${qty}</span>
                        <button onclick="updateCart('${code}', 1)" class="w-8 h-full flex items-center justify-center font-bold text-lg hover:bg-white/10 active:bg-white/20 rounded-r-lg">+</button>
                    </div>
                `;
            }
        }

        function renderCategories() {
            const container = document.getElementById('category-chips');
            // Get unique cats
            const cats = ['All', ...new Set(state.items.map(i => i.category || 'Other'))];
            container.innerHTML = cats.map(cat => {
                // Ensure strict comparison works by trimming or handling potential type issues if any
                const isActive = state.filter.category === cat;
                return `
                <button onclick="setCategory('${cat.replace(/'/g, "\\'")}')" 
                    class="category-chip px-4 py-1.5 rounded-full text-sm font-semibold whitespace-nowrap transition-all border ${isActive ? 'bg-gray-900 text-white border-gray-900 shadow-md' : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'}">
                    ${cat}
                </button>
            `}).join('');
        }



        // --- Interaction ---

        window.updateCart = (itemCode, change, allowFromTopView = false) => {
            markUserActive();
            // If pending request exists and not in edit mode, enable edit mode automatically
            // This allows editing from anywhere (menu items, cart summary, cart modal)
            if (state.pendingRequest && !state.isEditingPendingRequest) {
                state.isEditingPendingRequest = true;
            }

            // If item is not in cart, and we're trying to decrement, do nothing
            if (!state.cart[itemCode] && change < 0) return;

            // If item is not in cart, and we're trying to increment, add it
            if (!state.cart[itemCode] && change > 0) {
                const item = state.items.find(i => i.item_code === itemCode);
                if (item) {
                    state.cart[itemCode] = { qty: 0, item: item };
                } else {
                    console.warn(`Item with code ${itemCode} not found.`);
                    return;
                }
            }

            state.cart[itemCode].qty += change;

            if (state.cart[itemCode].qty <= 0) {
                delete state.cart[itemCode];
            }

            // Mark cart as modified if we're editing a pending request
            if (state.pendingRequest && state.isEditingPendingRequest) {
                state.cartModifiedFromPending = true;
            }

            // Update last cart update time for popup timer
            state.lastCartUpdateTime = Date.now();
            // Reset popup dismissal if new items were added
            const pendingQuantities = {};
            if (state.pendingRequest && state.pendingRequest.items) {
                state.pendingRequest.items.forEach(i => {
                    pendingQuantities[i.item_code] = i.quantity || 0;
                });
            }
            const hasNewItems = Object.entries(state.cart).some(([code, { qty }]) => {
                const pendingQty = pendingQuantities[code] || 0;
                return qty > pendingQty;
            });
            if (hasNewItems) {
                state.checkoutPopupDismissed = false;
            }

            updateFlowStatus();

            // Update UI
            updateCartBarUI();
            updateMenuQuantitiesOnly(); // Optimized UI update
            updateCartSummaryTop(); // Update cart summary at top

            // If cart modal is open, re-render it
            if (!document.getElementById('cart-modal').classList.contains('hidden')) {
                renderCartModalItems();
            }
        };

        window.updateCartBarUI = () => {
            const bar = document.getElementById('cart-bar');
            const items = Object.values(state.cart);
            
            // Calculate new items total (excluding pending items)
            const pendingQuantities = {};
            if (state.pendingRequest && state.pendingRequest.items) {
                state.pendingRequest.items.forEach(i => {
                    pendingQuantities[i.item_code] = i.quantity || 0;
                });
            }
            const cartTotal = items.reduce((sum, { qty, item }) => {
                const pendingQty = pendingQuantities[item.item_code] || 0;
                const newQty = Math.max(0, qty - pendingQty);
                return sum + (item.price * newQty);
            }, 0);
            
            // Show cart bar if there are items OR if there's an approved order (so user can view/add items)
            const hasItems = items.length > 0;
            const hasApprovedOrder = state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0;
            const hasNewItems = cartTotal > 0;
            const syncIndicator = bar.querySelector('#cart-sync-indicator');
            if (syncIndicator) {
                if (state.isSyncing) {
                    syncIndicator.classList.remove('hidden');
                } else {
                    syncIndicator.classList.add('hidden');
                }
            }
            
            if (!hasItems && !hasApprovedOrder) {
                bar.classList.add('hidden');
                return;
            }

            bar.classList.remove('hidden');

            // Calculate totals
            const totalQty = items.reduce((acc, c) => acc + c.qty, 0);
            const totalPrice = items.reduce((acc, c) => acc + (c.item.price * c.qty), 0);
            
            const cartLabel = bar.querySelector('.cart-label');
            const cartAction = bar.querySelector('.cart-action-text');
            const cartTotalEl = bar.querySelector('.cart-total');
            
            // If no items but approved order exists, show approved order info
            if (hasItems) {
                bar.querySelector('.cart-count').innerText = totalQty;
                
                if (hasNewItems) {
                    // Show only new items total when there are new items
                    if (cartLabel) cartLabel.textContent = 'New Items';
                    if (cartTotalEl) cartTotalEl.textContent = '‚Çπ' + cartTotal;
                    if (cartAction) cartAction.textContent = 'Checkout';
                } else {
                    // No new items ‚Äì show overall cart total
                    if (cartLabel) cartLabel.textContent = 'Total';
                    if (cartTotalEl) cartTotalEl.textContent = '‚Çπ' + totalPrice;
                    if (cartAction) cartAction.textContent = 'View Cart';
                }
            } else if (hasApprovedOrder) {
                // Show approved order info
                const approvedQty = state.existingOrder.items.reduce((sum, i) => sum + (i.quantity || 0), 0);
                const approvedTotal = state.existingOrder.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0);
                bar.querySelector('.cart-count').innerText = approvedQty;
                if (cartTotalEl) cartTotalEl.textContent = '‚Çπ' + approvedTotal;
                if (cartLabel) cartLabel.textContent = 'Order Total';
                if (cartAction) cartAction.textContent = 'View Order';
            }
            
            // Also update cart summary at top
            updateCartSummaryTop();
        };

        window.updateCartSummaryTop = () => {
            const summaryContainer = document.getElementById('cart-summary-top');
            const itemsContainer = document.getElementById('cart-summary-items');
            const totalContainer = document.getElementById('cart-summary-total');
            const totalAmountEl = document.getElementById('cart-summary-total-amount');
            const items = Object.values(state.cart);

            // Calculate full cart total (all items currently in cart)
            const totalPrice = items.reduce((acc, { qty, item }) => {
                return acc + (item.price * qty);
            }, 0);

            if (items.length === 0) {
                summaryContainer.classList.add('hidden');
                totalContainer.classList.add('hidden');
                return;
            }

            summaryContainer.classList.remove('hidden');
            totalContainer.classList.remove('hidden');

            // Show overall cart total
            totalAmountEl.textContent = '‚Çπ' + totalPrice;

            // Always allow editing from top view - this is the primary editing location
            // Show max 5 items, with "and X more" if needed
            const maxVisible = 5;
            const visibleItems = items.slice(0, maxVisible);
            const remainingCount = items.length - maxVisible;

            itemsContainer.innerHTML = visibleItems.map(({ qty, item }) => `
                <div class="flex items-center justify-between py-2 border-b border-gray-50 last:border-0">
                    <div class="flex-1 min-w-0">
                        <div class="font-semibold text-gray-900 text-sm truncate">${item.name}</div>
                        <div class="text-orange-600 font-bold text-xs">‚Çπ${item.price * qty}</div>
                    </div>
                    <div class="flex items-center bg-gray-100 rounded-lg h-7 ml-3">
                        <button onclick="updateCart('${item.item_code}', -1, true)" class="w-7 h-full flex items-center justify-center font-bold text-gray-600 text-sm hover:bg-gray-200 active:bg-gray-300 transition-colors">-</button>
                        <span class="w-5 text-center font-bold text-xs text-gray-900">${qty}</span>
                        <button onclick="updateCart('${item.item_code}', 1, true)" class="w-7 h-full flex items-center justify-center font-bold text-gray-900 text-sm hover:bg-gray-200 active:bg-gray-300 transition-colors">+</button>
                    </div>
                </div>
            `).join('') + (remainingCount > 0 ? `
                <div class="text-center py-2 text-sm text-gray-500 font-medium">
                    and ${remainingCount} more item${remainingCount > 1 ? 's' : ''}
                </div>
            ` : '');
        };

        // --- Interaction ---

        window.handleSearch = (val) => {
            state.filter.search = val.toLowerCase();
            document.getElementById('clear-search-btn').classList.toggle('hidden', val.length === 0);
            renderMenu();
        };

        window.clearSearch = () => {
            document.getElementById('search-input').value = '';
            handleSearch('');
        };

        window.setCategory = (cat) => {
            state.filter.category = cat;
            renderCategories(); // Update category chips to reflect new selection
            renderMenu();
        };

        // --- Cart Modal ---

        window.openCart = (fromStatusBanner = false) => {
            markUserActive();
            // Enable edit mode when opening cart modal (allows editing from modal)
            // Also enable if opening from status banner "View" button
            if (state.pendingRequest && (fromStatusBanner || !state.isEditingPendingRequest)) {
                state.isEditingPendingRequest = true;
                state.cartModifiedFromPending = false;
            }
            
            document.getElementById('cart-modal').classList.remove('hidden');
            renderCartModalItems();
            document.body.style.overflow = 'hidden';
            // Pickup: refresh status when opening cart so discount/updates from staff show immediately (like dine-in)
            if (state.isPickupMode && state.guestPhone && typeof checkPickupStatus === 'function') {
                checkPickupStatus(true).then(() => {
                    renderCartModalItems();
                    updateCartBarUI();
                    updateCartSummaryTop();
                }).catch(() => {});
            }
        };

        window.closeCart = () => {
            markUserActive();
            document.getElementById('cart-modal').classList.add('hidden');
            document.body.style.overflow = 'auto';
            // Don't clear editing flag if cart has been modified - preserve user edits
            // Only clear if cart is empty or user explicitly wants to cancel
            if (Object.keys(state.cart).length === 0) {
                state.isEditingPendingRequest = false;
                state.cartModifiedFromPending = false;
            }
            // Update menu to reflect current state (read-only if pending exists)
            updateMenuQuantitiesOnly();
            updateCartSummaryTop(); // Update cart summary when modal closes
        };

        // --- Updated Cart Modal Rendering ---

        function renderCartModalItems() {
            const container = document.getElementById('cart-items-list');
            const submitBtn = document.getElementById('place-order-btn');
            const cancelBtn = document.getElementById('cancel-req-btn');

            const existingSection = document.getElementById('existing-order-section');
            const existingList = document.getElementById('existing-items-list');
            
            // Update cancel button visibility
            if (cancelBtn) {
                if (state.pendingRequest) {
                    cancelBtn.classList.remove('hidden');
                } else {
                    cancelBtn.classList.add('hidden');
                }
            }
            

            // 1. Pending Items Section (NEW)
            let pendingSection = document.getElementById('pending-order-section');
            if (!pendingSection) {
                pendingSection = document.createElement('div');
                pendingSection.id = 'pending-order-section';
                pendingSection.className = 'hidden mb-4 border border-orange-200 bg-orange-50/50 rounded-2xl p-4';
                pendingSection.innerHTML = `
                    <h3 class="font-bold text-orange-800 text-sm uppercase tracking-wide mb-3 flex items-center gap-2">
                        <span class="w-2 h-2 bg-orange-500 rounded-full animate-pulse"></span>
                         Waiting for Approval
                    </h3>
                    <div id="pending-items-list" class="space-y-2 text-sm text-gray-700"></div>
                `;
                // Insert before existing section if possible, else append
                if (existingSection && existingSection.parentNode) {
                    existingSection.parentNode.insertBefore(pendingSection, existingSection);
                }
            }

            // Hide pending section - items will be shown in cart with editable quantities
            if (pendingSection) {
                pendingSection.classList.add('hidden');
            }

            // 2. Existing \"On Table\" Items (Approved/Billed Order)
            const hasExistingItems = state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0;
            const billDetailsFromServer = state.existingOrder && state.existingOrder.bill_details ? state.existingOrder.bill_details : null;
            if (hasExistingItems) {
                existingSection.classList.remove('hidden');
                
                // Calculate approved order total. Prefer backend bill_details.total when available.
                const approvedTotal = billDetailsFromServer && typeof billDetailsFromServer.total === 'number'
                    ? billDetailsFromServer.total
                    : state.existingOrder.items.reduce((sum, i) => {
                        return sum + ((i.price || 0) * (i.quantity || 0));
                    }, 0);
                
                existingList.innerHTML = state.existingOrder.items.map(i => `
                    <div class="flex justify-between items-center py-1">
                        <span class="flex items-center gap-2"><span class="w-1.5 h-1.5 bg-green-500 rounded-full"></span> ${i.name}</span>
                        <span class="font-bold text-gray-500">x${i.quantity}</span>
                    </div>
                    `).join('') + `
                    <div class="flex justify-between items-center pt-2 mt-2 border-t border-green-200">
                        <span class="font-bold text-green-800 text-sm">Approved Total:</span>
                        <span class="font-bold text-green-800 text-sm">‚Çπ${approvedTotal}</span>
                    </div>
                `;
            } else {
                existingSection.classList.add('hidden');
            }

            // 3. Current Cart - Show all items (pending + new) with editable quantities
            // Create a map of pending request quantities for reference
            const pendingQuantities = {};
            if (state.pendingRequest && state.pendingRequest.items) {
                state.pendingRequest.items.forEach(i => {
                    pendingQuantities[i.item_code] = i.quantity || 0;
                });
            }
            
            // Merge pending items into cart if they're not already there
            // This ensures all pending items are visible and editable
            if (state.pendingRequest && state.pendingRequest.items) {
                state.pendingRequest.items.forEach(pi => {
                    const originalItem = state.itemsMap[pi.item_code] || pi;
                    // Only add if not already in cart (preserve any user modifications)
                    if (!state.cart[pi.item_code]) {
                        state.cart[pi.item_code] = {
                            qty: pi.quantity,
                            item: originalItem
                        };
                    }
                });
            }
            
            // Recalculate entries after merging
            const allEntries = Object.entries(state.cart);
            
            // Calculate totals
            // Cart total: count only the difference in quantities (increases) as new items
            const cartTotal = allEntries.reduce((sum, [code, { qty, item }]) => {
                const pendingQty = pendingQuantities[code] || 0;
                const newQty = Math.max(0, qty - pendingQty); // Only count the increase
                return sum + (item.price * newQty);
            }, 0);
            
            // Pending total: original pending quantities
            const pendingTotal = state.pendingRequest && state.pendingRequest.items ? 
                state.pendingRequest.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0) : 0;
            
            // Update submit button state based on new items (use cartTotal calculated here)
            const hasNewItems = cartTotal > 0;
            const canEdit = !state.pendingRequest || state.isEditingPendingRequest;
            if (!hasNewItems) {
                // Hide button when no new items
                submitBtn.style.display = 'none';
            } else if (state.pendingRequest && !state.isEditingPendingRequest) {
                // Disable submit button when pending request exists but not in edit mode
                submitBtn.style.display = 'block';
                submitBtn.disabled = true;
                submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
                submitBtn.innerHTML = `<span>Use "Edit Order" to modify</span>`;
            } else {
                // Show checkout button when there are new items (or "Save changes" when editing approved pickup order)
                submitBtn.style.display = 'block';
                submitBtn.disabled = false;
                submitBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                const isEditingApprovedPickup = state.isPickupMode && state.existingOrder && state.existingOrder.order_id;
                submitBtn.innerHTML = isEditingApprovedPickup
                    ? `<span>Send request</span>`
                    : `<span class="inline-flex items-center justify-center gap-2"><span>Checkout</span><svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg></span>`;
            }
            
            // Show all items in cart (pending + new)
            // If cart is empty but there's an approved order, show helpful message
            if (allEntries.length === 0) {
                if (state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0) {
                    container.innerHTML = `
                        <div class="text-center py-8">
                            <div class="text-gray-400 text-sm mb-2">Your approved order is shown above</div>
                            <div class="text-gray-500 text-xs">Add more items to your order below</div>
                        </div>
                    `;
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-400 text-sm">No items in cart</div>';
                }
            } else {
                container.innerHTML = allEntries.map(([code, { qty, item }]) => {
                    const pendingQty = pendingQuantities[code] || 0;
                    const isPendingItem = pendingQty > 0;
                    const newQty = Math.max(0, qty - pendingQty);
                    
                    return `
                    <div class="flex items-center justify-between py-3 border-b border-gray-50 last:border-0 ${isPendingItem ? 'bg-orange-50/30' : ''}">
                        <div class="flex-1">
                            <div class="flex items-center gap-2">
                                <div class="font-bold text-gray-900 text-[15px]">${item.name}</div>
                                ${isPendingItem ? `
                                <span class="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded-full font-semibold">Pending</span>
                                ` : ''}
                            </div>
                            ${isPendingItem && newQty > 0 ? `
                            <div class="text-xs text-gray-500 mb-1">+${newQty} more added</div>
                            ` : ''}
                            <div class="text-orange-600 font-bold text-xs">‚Çπ${item.price * qty}</div>
                        </div>
                        ${canEdit ? `
                        <div class="flex items-center bg-gray-100 rounded-lg h-8">
                            <button onclick="updateCart('${code}', -1, true)" class="w-8 h-full flex items-center justify-center font-bold text-gray-600">-</button>
                            <span class="w-6 text-center font-bold text-sm text-gray-900">${qty}</span>
                            <button onclick="updateCart('${code}', 1, true)" class="w-8 h-full flex items-center justify-center font-bold text-gray-900">+</button>
                        </div>
                        ` : `
                        <div class="flex items-center bg-gray-200 rounded-lg h-8 px-3">
                            <span class="text-center font-bold text-sm text-gray-600">${qty}</span>
                        </div>
                        `}
                    </div>
                    `;
                }).join('');
            }
            
            // 4. Combined Total Section
            let combinedTotalSection = document.getElementById('combined-total-section');
            if (!combinedTotalSection) {
                combinedTotalSection = document.createElement('div');
                combinedTotalSection.id = 'combined-total-section';
                combinedTotalSection.className = 'mt-4 pt-4 border-t-2 border-gray-300';
                // Insert before guest form
                const guestForm = document.querySelector('.pt-6.mt-6.border-t');
                if (guestForm && guestForm.parentNode) {
                    guestForm.parentNode.insertBefore(combinedTotalSection, guestForm);
                }
            }
            
            // Calculate all totals for combined section
            // Recalculate pending total (original pending quantities)
            const pendingTotalForCombined = state.pendingRequest && state.pendingRequest.items ? 
                state.pendingRequest.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0) : 0;
            // Prefer backend bill_details for approved/billed totals and discount breakdown
            const approvedBillDetails = state.existingOrder && state.existingOrder.bill_details ? state.existingOrder.bill_details : null;
            const approvedTotal = approvedBillDetails && typeof approvedBillDetails.total === 'number'
                ? approvedBillDetails.total
                : (state.existingOrder && state.existingOrder.items 
                    ? state.existingOrder.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0) 
                    : 0);
            // Total order value = approved (to pay now) + pending (future) ‚Äì excludes unsent new items
            const totalOrderValue = approvedTotal + pendingTotalForCombined;
            
            // Show combined total section if there is anything meaningful to display
            if (approvedTotal > 0 || pendingTotalForCombined > 0) {
                combinedTotalSection.classList.remove('hidden');
                combinedTotalSection.innerHTML = `
                    <div class="bg-gray-900 text-white rounded-2xl p-4 space-y-4">
                        <!-- Payment Due (Approved items only) -->
                        ${approvedTotal > 0 ? `
                        <div>
                            <div class="text-xs font-semibold tracking-wide text-gray-300 uppercase mb-1">Payment Due Now</div>
                            <div class="flex items-baseline justify-between">
                                <span class="text-2xl font-bold text-green-400">‚Çπ${approvedTotal.toFixed(2)}</span>
                            </div>
                            <div class="text-[11px] text-gray-400 mt-1">(Approved items only)</div>
                        </div>
                        ` : ''}

                        <!-- Approved items breakdown -->
                        ${approvedBillDetails ? `
                        <div class="pt-3 border-t border-gray-700">
                            <div class="text-xs font-semibold text-gray-300 uppercase mb-2">Approved Items</div>
                            <div class="flex justify-between items-center text-xs mb-1">
                                <span class="text-gray-300">Subtotal</span>
                                <span class="text-gray-100">‚Çπ${Number(approvedBillDetails.sub_total || 0).toFixed(2)}</span>
                            </div>
                            ${approvedBillDetails.discount > 0 ? `
                            <div class="flex justify-between items-center text-xs mb-1">
                                <span class="text-gray-300">Discount</span>
                                <span class="text-red-300">-‚Çπ${Number(approvedBillDetails.discount || 0).toFixed(2)}</span>
                            </div>` : ''}
                            ${(approvedBillDetails.cgst > 0 || approvedBillDetails.sgst > 0) ? `
                            <div class="flex justify-between items-center text-xs mb-1">
                                <span class="text-gray-300">Tax (CGST + SGST)</span>
                                <span class="text-gray-100">‚Çπ${(Number(approvedBillDetails.cgst || 0) + Number(approvedBillDetails.sgst || 0)).toFixed(2)}</span>
                            </div>` : ''}
                            <div class="border-t border-gray-700 my-2"></div>
                            <div class="flex justify-between items-center text-sm font-semibold">
                                <span class="text-gray-100">Total to Pay</span>
                                <span class="text-green-400">‚Çπ${approvedTotal.toFixed(2)}</span>
                            </div>
                        </div>
                        ` : ''}

                        <!-- Pending items (informational) -->
                        ${pendingTotalForCombined > 0 ? `
                        <div class="pt-3 border-t border-gray-800">
                            <div class="flex justify-between items-center text-sm">
                                <span class="text-gray-300">Pending Items (Not charged yet)</span>
                                <span class="font-semibold text-orange-400">‚Çπ${pendingTotalForCombined.toFixed(2)}</span>
                            </div>
                            <div class="text-[11px] text-gray-500 mt-1">You‚Äôll be charged after approval.</div>
                        </div>
                        ` : ''}

                        <!-- Optional total order value -->
                        ${totalOrderValue > 0 && pendingTotalForCombined > 0 ? `
                        <div class="pt-2 border-t border-gray-800">
                            <div class="flex justify-between items-center text-[11px] text-gray-500">
                                <span>Total order value (approved + pending)</span>
                                <span>‚Çπ${totalOrderValue.toFixed(2)}</span>
                            </div>
                        </div>
                        ` : ''}
                    </div>
                `;
            } else {
                combinedTotalSection.classList.add('hidden');
            }

            // 5. Pay via UPI: show when we have at least one approved order (dine-in table or pickup phone) and UPI is set
            let upiSection = document.getElementById('upi-pay-section');
            const hasUpi = !!(state.settings.upi_id || state.settings.upi_number || state.settings.upi_qr_url);
            const hasApprovedOrder = state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0;
            const showPaySection = hasUpi && hasApprovedOrder;
            if (typeof console !== 'undefined' && console.log) {
                console.log('[PAY_DEBUG] Pay section visibility:', {
                    hasUpi,
                    hasApprovedOrder,
                    existingOrderExists: !!state.existingOrder,
                    existingOrderItemsCount: state.existingOrder ? (state.existingOrder.items && state.existingOrder.items.length) : 0,
                    showPaySection,
                    isPickupMode: state.isPickupMode
                });
                if (!hasUpi && hasApprovedOrder) {
                    console.log('[PAY_DEBUG] Pay is hidden because UPI is not configured. Set UPI ID and/or UPI Number in Web App ‚Üí Operations ‚Üí Guest Ordering ‚Üí Save. Then refresh the menu page.');
                }
            }
            const payBtn = document.getElementById('pay-via-upi-btn');
            if (payBtn) payBtn.classList.toggle('hidden', !showPaySection);
            if (showPaySection) {
                if (!upiSection) {
                    upiSection = document.createElement('div');
                    upiSection.id = 'upi-pay-section';
                    upiSection.className = 'mt-4 pt-4 border-t border-gray-200';
                    const guestForm = document.querySelector('.pt-6.mt-6.border-t.border-gray-100');
                    if (guestForm && guestForm.parentNode) guestForm.parentNode.insertBefore(upiSection, guestForm);
                }
                const approvedBillForUpi = state.existingOrder && state.existingOrder.bill_details ? state.existingOrder.bill_details : null;
                const approvedTotal = approvedBillForUpi && typeof approvedBillForUpi.total === 'number'
                    ? approvedBillForUpi.total
                    : (state.existingOrder.items ? state.existingOrder.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0) : 0);
                const restaurantName = (state.settings.restaurant_name || 'Restaurant').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const upiId = (state.settings.upi_id || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const upiNumber = (state.settings.upi_number || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const esc = (s) => String(s || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                upiSection.classList.remove('hidden');
                upiSection.innerHTML = `
                    <h3 class="font-bold text-gray-900 text-sm uppercase tracking-wide mb-3 flex items-center gap-2">
                        <span class="text-green-600">Pay via UPI</span>
                    </h3>
                    <div class="bg-gray-50 rounded-xl p-4 space-y-3 text-sm">
                        <div class="flex justify-between items-center py-2 border-b border-gray-200">
                            <span class="text-gray-600 font-medium">Amount to pay (approved order)</span>
                            <span class="font-bold text-gray-900 text-lg">‚Çπ${approvedTotal}</span>
                        </div>
                        <div class="flex justify-between items-center gap-2 flex-wrap">
                            <span class="text-gray-600">UPI ID</span>
                            <span class="font-semibold text-gray-900 break-all text-right">${upiId || '‚Äî'}</span>
                            ${state.settings.upi_id ? `<button type="button" data-copy-value="${esc(state.settings.upi_id)}" data-copy-label="UPI ID" onclick="copyFromButton(this)" class="flex-shrink-0 px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded-lg text-xs font-medium">Copy</button>` : ''}
                        </div>
                        <div class="flex justify-between items-center gap-2 flex-wrap">
                            <span class="text-gray-600">UPI Number</span>
                            <span class="font-semibold text-gray-900">${upiNumber || '‚Äî'}</span>
                            ${state.settings.upi_number ? `<button type="button" data-copy-value="${esc(state.settings.upi_number)}" data-copy-label="UPI Number" onclick="copyFromButton(this)" class="flex-shrink-0 px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded-lg text-xs font-medium">Copy</button>` : ''}
                        </div>
                        ${state.settings.upi_qr_url ? `<div class="mt-3 flex justify-center"><img src="${state.settings.upi_qr_url}" alt="UPI QR Code" class="w-40 h-40 object-contain border border-gray-200 rounded-lg" onerror="this.style.display='none'"></div>` : ''}
                        <div class="flex gap-2 mt-3 items-stretch w-full px-3">
                            ${state.settings.upi_id ? `
                            <button type="button" data-upi-id="${esc(state.settings.upi_id)}" data-payee-name="" data-amount="${approvedTotal}" onclick="openUpiPayWithApp(this, 'gpay')" class="flex-1 flex items-center justify-center min-w-0 h-14 rounded-xl bg-white border border-gray-200 shadow-md hover:shadow-lg active:shadow active:scale-[0.98] cursor-pointer transition-all duration-200" title="Pay with GPay">
                                <img src="https://upload.wikimedia.org/wikipedia/commons/f/f2/Google_Pay_Logo.svg" alt="GPay" class="w-10 h-10 object-contain scale-150" onerror="this.style.display='none'" />
                            </button>
                            <button type="button" data-upi-id="${esc(state.settings.upi_id)}" data-payee-name="" data-amount="${approvedTotal}" onclick="openUpiPayWithApp(this, 'phonepe')" class="flex-1 flex items-center justify-center min-w-0 h-14 rounded-xl bg-white border border-gray-200 shadow-md hover:shadow-lg active:shadow active:scale-[0.98] cursor-pointer transition-all duration-200" title="Pay with PhonePe">
                                <img src="https://upload.wikimedia.org/wikipedia/commons/7/71/PhonePe_Logo.svg" alt="PhonePe" class="h-7 w-auto max-w-full object-contain" onerror="this.style.display='none'" />
                            </button>
                            <button type="button" data-upi-id="${esc(state.settings.upi_id)}" data-payee-name="" data-amount="${approvedTotal}" onclick="openUpiPayWithApp(this, 'paytm')" class="flex-1 flex items-center justify-center min-w-0 h-14 rounded-xl bg-white border border-gray-200 shadow-md hover:shadow-lg active:shadow active:scale-[0.98] cursor-pointer transition-all duration-200" title="Pay with Paytm">
                                <img src="https://upload.wikimedia.org/wikipedia/commons/2/24/Paytm_Logo_(standalone).svg" alt="Paytm" class="h-6 w-auto max-w-full object-contain" onerror="this.style.display='none'" />
                            </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            } else if (upiSection) {
                upiSection.classList.add('hidden');
            }
        }

        window.startEditingApprovedPickupOrder = () => {
            if (!state.existingOrder || !state.existingOrder.items) return;
            state.isEditingApprovedPickupOrder = true;
            state.cart = {};
            state.existingOrder.items.forEach(pi => {
                const code = pi.item_code || pi.code;
                const originalItem = state.itemsMap[code] || pi;
                state.cart[code] = { qty: pi.quantity || 0, item: originalItem };
            });
            if (!document.getElementById('cart-modal').classList.contains('hidden')) renderCartModalItems();
            updateCartBarUI();
        };

        window.cancelEditingApprovedPickupOrder = () => {
            state.isEditingApprovedPickupOrder = false;
            state.cart = {};
            if (!document.getElementById('cart-modal').classList.contains('hidden')) renderCartModalItems();
            updateCartBarUI();
        };

        window.saveApprovedPickupOrder = async () => {
            if (!state.existingOrder || !state.existingOrder.order_id) return;
            const itemsPayload = Object.values(state.cart).map(c => ({
                item_code: c.item.item_code || c.item.code,
                name: c.item.name,
                price: c.item.price,
                quantity: c.qty,
                category: c.item.category,
                is_cgst_applicable: c.item.is_cgst_applicable,
                is_sgst_applicable: c.item.is_sgst_applicable,
                group_id: c.item.group_id,
                group: c.item.group
            }));
            if (itemsPayload.length === 0) return alert('Order must have at least one item.');
            const btn = document.getElementById('place-order-btn');
            if (btn) { btn.disabled = true; btn.innerHTML = '<div class="w-5 h-5 border-2 border-white rounded-full border-t-transparent animate-spin"></div><span>Saving...</span>'; }
            try {
                const res = await axios.put(`${LAMBDA_URL}/pickup/order`, { tenant_id: state.tenantId, order_id: state.existingOrder.order_id, items: itemsPayload });
                if (res.data.success) {
                    state.isEditingApprovedPickupOrder = false;
                    state.cart = {};
                    state.existingOrder.items = itemsPayload;
                    await checkPickupStatus(true);
                    if (!document.getElementById('cart-modal').classList.contains('hidden')) renderCartModalItems();
                    updateCartBarUI();
                    alert('Order updated.');
                } else {
                    alert(res.data.message || 'Update failed');
                }
            } catch (err) {
                alert(err.response?.data?.error || err.response?.data?.message || 'Connection error');
                console.error(err);
            } finally {
                if (btn) { btn.disabled = false; btn.innerHTML = '<span>Save changes</span>'; }
            }
        };

        window.scrollToPaySection = () => {
            const el = document.getElementById('upi-pay-section');
            if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        };

        /**
         * Build UPI query string (pa, optional pn, am, cu=INR). If pn is not sent, the UPI app
         * fetches the payee name automatically from the UPI ID (pa) via the bank/NPCI directory.
         */
        function buildUpiQuery(pa, pn, amount) {
            const am = Number(amount) >= 0 ? Number(amount).toFixed(2) : '0.00';
            const paEnc = encodeURIComponent(String(pa).trim());
            const parts = [`pa=${paEnc}`, `am=${am}`, 'cu=INR'];
            if (pn && String(pn).trim() !== '') {
                parts.splice(1, 0, `pn=${encodeURIComponent(String(pn).trim())}`);
            }
            return parts.join('&');
        }

        /**
         * Open UPI payment in a specific app (gpay, phonepe, paytm) or generic upi://.
         * Uses app-specific URL schemes so the correct app opens (browsers often ignore intent package= and open default UPI app e.g. WhatsApp).
         * Paytm: paytmmp://pay. GPay: gpay://upi/pay. PhonePe: phonepe://pay.
         */
        window.openUpiPayToApp = (pa, pn, amount, app) => {
            if (!pa) return;
            const query = buildUpiQuery(pa, pn, amount);
            const isAndroid = /Android/i.test(navigator.userAgent);

            let urlToOpen = `upi://pay?${query}`;
            if (app === 'paytm') {
                urlToOpen = `paytmmp://pay?${query}`;
            } else if (app === 'gpay') {
                // GPay's own scheme opens the app directly; avoids generic upi:// defaulting to WhatsApp
                urlToOpen = `gpay://upi/pay?${query}`;
            } else if (app === 'phonepe') {
                // PhonePe's scheme opens the app directly
                urlToOpen = `phonepe://pay?${query}`;
            } else if (isAndroid && !app) {
                urlToOpen = `intent://pay?${query}#Intent;scheme=upi;action=android.intent.action.VIEW;end`;
            }

            const useIntent = urlToOpen.startsWith('intent://');
            if (useIntent) {
                const a = document.createElement('a');
                a.href = urlToOpen;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } else {
                window.location.href = urlToOpen;
            }
        };

        window.openUpiPayWithApp = (btn, app) => {
            const pa = btn.getAttribute('data-upi-id');
            const pn = btn.getAttribute('data-payee-name') || '';
            const am = btn.getAttribute('data-amount');
            if (pa != null && am != null) window.openUpiPayToApp(pa, pn, am, app);
        };

        /**
         * Open UPI payment with payee and amount (generic app chooser). Uses intent URL on Android with ACTION_VIEW.
         */
        window.openUpiPay = (pa, pn, amount) => {
            window.openUpiPayToApp(pa, pn, amount, null);
        };

        window.openUpiPayFromButton = (btn) => {
            const pa = btn.getAttribute('data-upi-id');
            const pn = btn.getAttribute('data-payee-name') || '';
            const am = btn.getAttribute('data-amount');
            if (pa != null && am != null) window.openUpiPay(pa, pn, am);
        };

        window.copyFromButton = (btn) => {
            const value = btn.getAttribute('data-copy-value') || '';
            const label = btn.getAttribute('data-copy-label') || '';
            copyToClipboard(value, label);
        };
        window.copyToClipboard = (text, label) => {
            if (!navigator.clipboard || !navigator.clipboard.writeText) {
                try { const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); } catch (e) {}
            } else {
                navigator.clipboard.writeText(text).catch(() => {});
            }
            const Toast = document.createElement('div');
            Toast.className = 'fixed bottom-4 left-1/2 -translate-x-1/2 bg-gray-900 text-white px-4 py-2 rounded-lg text-sm z-[100] animate-fade-in';
            Toast.textContent = (label || 'Copied') + ' copied!';
            document.body.appendChild(Toast);
            setTimeout(() => Toast.remove(), 2000);
        };

        window.submitOrder = async () => {
            const btn = document.getElementById('place-order-btn');
            if (Object.keys(state.cart).length === 0) return alert('Cart is empty');
            
            // Prevent submission if pending request exists but not in edit mode
            if (state.pendingRequest && !state.isEditingPendingRequest) {
                return alert('Please use "View / Edit" button to modify your pending order');
            }

            markUserActive();
            state.isSyncing = true;
            updateCartBarUI();

            btn.innerHTML = `<div class="w-5 h-5 border-2 border-white rounded-full border-t-transparent animate-spin"></div><span>Sending...</span>`;
            btn.disabled = true;

            // Sync guest details from inputs into state
            const guestNameInput = (document.getElementById('guest-name')?.value || "").trim();
            const guestPhoneInput = (document.getElementById('guest-phone')?.value || "").trim();
            if (guestNameInput) state.guestName = guestNameInput;
            if (guestPhoneInput) state.guestPhone = guestPhoneInput;

            // For pickup mode, enforce phone + name before submit
            if (state.isPickupMode) {
                const normalizedPhone = normalizeTenDigitPhone(state.guestPhone);
                if (!normalizedPhone) {
                    alert('Please enter a valid 10-digit phone number for pickup orders.');
                    state.isSyncing = false;
                    updateCartBarUI();
                    btn.disabled = false;
                    btn.innerHTML = `<span class="inline-flex items-center justify-center gap-2"><span>Checkout</span><svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg></span>`;
                    return;
                }
                state.guestPhone = normalizedPhone;
                if (!state.guestName) {
                    alert('Name is required for pickup orders.');
                    state.isSyncing = false;
                    updateCartBarUI();
                    btn.disabled = false;
                    btn.innerHTML = `<span class="inline-flex items-center justify-center gap-2"><span>Checkout</span><svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg></span>`;
                    return;
                }
            }

            const baseItems = Object.values(state.cart).map(c => ({
                item_code: c.item.item_code,
                name: c.item.name,
                price: c.item.price,
                quantity: c.qty,
                category: c.item.category,
                is_cgst_applicable: c.item.is_cgst_applicable,
                is_sgst_applicable: c.item.is_sgst_applicable,
                group_id: c.item.group_id,
                group: c.item.group
            }));

            // Pickup with existing approved order: if user is editing the full approved order, send only delta (additions)
            // Otherwise (normal flow), the cart already represents the items to add, so send as-is.
            let pickupItems = baseItems;
            if (state.isPickupMode && state.isEditingApprovedPickupOrder && state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0) {
                const existingQtyByKey = {};
                (state.existingOrder.items || []).forEach(i => {
                    const code = String(i.item_code != null ? i.item_code : i.code || '').trim();
                    const key = (i.portion ? `${code}_${i.portion}` : code);
                    if (code) existingQtyByKey[key] = (existingQtyByKey[key] || 0) + (Number(i.quantity) || 0);
                });
                const deltaItems = baseItems.filter(c => {
                    const code = String(c.item_code != null ? c.item_code : c.code || '').trim();
                    const portion = c.portion || (c.item && c.item.portion);
                    const key = (portion ? `${code}_${portion}` : code);
                    const cartQty = Number(c.quantity) || 0;
                    const existingQty = existingQtyByKey[key] || 0;
                    const addQty = Math.max(0, cartQty - existingQty);
                    c.quantity = addQty;
                    return addQty > 0;
                });
                if (deltaItems.length === 0) {
                    alert('Add at least one new item to send a request. Your approved order already has the current items.');
                    return;
                }
                pickupItems = deltaItems;
            }

            const payload = state.isPickupMode
                ? {
                    tenant_id: state.tenantId,
                    items: pickupItems,
                    guest_name: state.guestName || "Guest",
                    guest_phone: state.guestPhone,
                    order_type: "pickup",
                }
                : {
                    tenant_id: state.tenantId,
                    table_id: state.tableId,
                    hall_id: state.hallId,
                    items: baseItems,
                    guest_name: state.guestName || "Guest",
                    guest_phone: state.guestPhone || ""
                };

            try {
                const res = await axios.post(LAMBDA_URL, payload);
                if (res.data.success) {
                    state.cart = {};
                    state.isEditingPendingRequest = false; // Clear editing flag
                    state.cartModifiedFromPending = false; // Clear modification flag
                    state.lastCartUpdateTime = null; // Reset timer
                    state.checkoutPopupDismissed = false; // Reset popup dismissal
                    updateCartBarUI();
                    updateMenuQuantitiesOnly(); // Reset quantity buttons
                    closeCart();
                    document.getElementById('confirm-dialog').classList.remove('hidden');
                    document.getElementById('confirm-dialog').classList.add('flex');
                    // Force immediate status check
                    if (state.isPickupMode) {
                        checkPickupStatus(true);
                    } else {
                        checkTableStatus(true);
                    }
                } else {
                    alert(res.data.message || 'Failed to submit order'); // Improved error msg
                }
            } catch (err) {
                alert('Connection Error');
                console.error(err);
            } finally {
                // Recalculate to determine button text
                const pendingQuantities = {};
                if (state.pendingRequest && state.pendingRequest.items) {
                    state.pendingRequest.items.forEach(i => {
                        pendingQuantities[i.item_code] = i.quantity || 0;
                    });
                }
                const items = Object.values(state.cart);
                const cartTotal = items.reduce((sum, { qty, item }) => {
                    const pendingQty = pendingQuantities[item.item_code] || 0;
                    const newQty = Math.max(0, qty - pendingQty);
                    return sum + (item.price * newQty);
                }, 0);
                const hasNewItems = cartTotal > 0;
                
                if (hasNewItems) {
                    btn.innerHTML = `<span class="inline-flex items-center justify-center gap-2"><span>Checkout</span><svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg></span>`;
                } else {
                    btn.style.display = 'none';
                }
                state.isSyncing = false;
                updateCartBarUI();
                btn.disabled = false;
            }
        };


        window.closeConfirmDialog = () => {
            document.getElementById('confirm-dialog').classList.add('hidden');
            document.getElementById('confirm-dialog').classList.remove('flex');
        };

        window.scrollToActiveItems = () => {
            openCart();
        };

        // Checkout Reminder Functions
        window.dismissCheckoutReminder = () => {
            state.checkoutPopupDismissed = true;
            document.getElementById('checkout-reminder-popup').classList.add('hidden');
            document.getElementById('checkout-reminder-popup').classList.remove('flex');
        };

        window.openCartFromReminder = () => {
            document.getElementById('checkout-reminder-popup').classList.add('hidden');
            document.getElementById('checkout-reminder-popup').classList.remove('flex');
            state.checkoutPopupDismissed = false; // Reset so they can see it again if needed
            state.lastCartUpdateTime = Date.now(); // Reset timer
            openCart();
        };

        // Check for checkout reminder (runs every 10 seconds)
        window.checkCheckoutReminder = () => {
            // Don't show if already dismissed or if popup is already visible
            if (state.checkoutPopupDismissed) return;
            const popup = document.getElementById('checkout-reminder-popup');
            if (!popup.classList.contains('hidden')) return;

            // Calculate if there are new items
            const pendingQuantities = {};
            if (state.pendingRequest && state.pendingRequest.items) {
                state.pendingRequest.items.forEach(i => {
                    pendingQuantities[i.item_code] = i.quantity || 0;
                });
            }
            const items = Object.values(state.cart);
            const cartTotal = items.reduce((sum, { qty, item }) => {
                const pendingQty = pendingQuantities[item.item_code] || 0;
                const newQty = Math.max(0, qty - pendingQty);
                return sum + (item.price * newQty);
            }, 0);

            // Only show if there are new items and 1 minute has passed
            if (cartTotal > 0 && state.lastCartUpdateTime && (Date.now() - state.lastCartUpdateTime) > 60000) {
                popup.classList.remove('hidden');
                popup.classList.add('flex');
            }
        };

        // Start
        init();
        
        // Start checkout reminder interval (check every 10 seconds)
        setInterval(checkCheckoutReminder, 10000);

    </script>
</body>

</html>
