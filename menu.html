<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Restaurant Menu</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üçΩÔ∏è</text></svg>">

    <!-- Fonts & Tailwind -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&family=Quicksand:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Plus Jakarta Sans"', 'sans-serif'],
                        display: ['"Quicksand"', 'sans-serif'],
                    },
                    colors: {
                        orange: {
                            50: '#fff7ed', 100: '#ffedd5', 200: '#fed7aa', 300: '#fdba74',
                            400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c',
                            800: '#9a3412', 900: '#7c2d12',
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #f9fafb;
            -webkit-tap-highlight-color: transparent;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.6);
        }

        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .animate-slide-up {
            animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        .animate-fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
            }

            to {
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Smooth image loading */
        img {
            transition: opacity 0.3s ease-in-out;
        }

        img[loading] {
            opacity: 0;
        }

        img.loaded {
            opacity: 1;
        }
    </style>
</head>

<body
    class="bg-gray-50 text-gray-800 font-sans min-h-screen pb-28 relative overflow-x-hidden selection:bg-orange-100 selection:text-orange-900">

    <!-- Background -->
    <div class="fixed inset-0 pointer-events-none z-0 overflow-hidden">
        <div class="absolute -top-[10%] -left-[10%] w-[50%] h-[50%] bg-orange-200/20 rounded-full blur-[100px]"></div>
        <div class="absolute top-[20%] -right-[10%] w-[40%] h-[40%] bg-blue-200/10 rounded-full blur-[100px]"></div>
    </div>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 relative z-10">

        <!-- Header -->
        <header id="restaurant-header" class="text-center mb-8 animate-fade-in">
            <!-- Dynamic Content -->
            <div class="h-24 flex items-center justify-center">
                <div class="w-8 h-8 border-2 border-orange-500 rounded-full border-t-transparent animate-spin"></div>
            </div>
        </header>

        <!-- Search Bar -->
        <div class="sticky top-0 z-40 bg-gray-50/95 backdrop-blur-md pb-4 pt-2 -mx-4 px-4 sm:px-6 transition-all duration-300 shadow-sm"
            id="search-bar-container">
            <div class="relative max-w-lg mx-auto">
                <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none"
                        viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                </div>
                <input type="text" id="search-input"
                    class="block w-full pl-10 pr-10 py-3 border-none rounded-2xl leading-5 bg-white text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-orange-500 shadow-md shadow-gray-100/50"
                    placeholder="Search for dishes..." oninput="handleSearch(this.value)" />

                <!-- Clear Button -->
                <button id="clear-search-btn" onclick="clearSearch()"
                    class="absolute inset-y-0 right-0 pr-3 flex items-center hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 hover:text-gray-600"
                        viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd"
                            d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                            clip-rule="evenodd" />
                    </svg>
                </button>
            </div>

            <!-- Category Chips -->
            <div class="flex items-center gap-2 overflow-x-auto hide-scrollbar mt-3 pb-1 max-w-lg mx-auto"
                id="category-chips">
                <!-- Injected dynamically -->
            </div>
        </div>

        <!-- Cart Summary (Top of Menu) -->
        <div id="cart-summary-top" class="hidden mt-6 mb-6">
            <div class="bg-white rounded-2xl shadow-md border border-gray-100 p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="font-bold text-gray-900 text-lg flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-orange-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z" />
                        </svg>
                        Cart
                    </h3>
                    <button onclick="openCart()" class="text-sm font-semibold text-orange-600 hover:text-orange-700">
                        View All
                    </button>
                </div>
                <div id="cart-summary-items" class="space-y-2">
                    <!-- Cart items will be injected here -->
                </div>
                <!-- Total Amount -->
                <div id="cart-summary-total" class="hidden mt-4 pt-4 border-t border-gray-200 flex items-center justify-between">
                    <span class="font-bold text-gray-700 text-sm">Total:</span>
                    <span class="font-bold text-orange-600 text-lg" id="cart-summary-total-amount">‚Çπ0</span>
                </div>
            </div>
        </div>

        <!-- Items Grid -->
        <div id="items-container" class="space-y-10 mt-6 min-h-[50vh]">
            <div class="flex flex-col items-center justify-center py-20">
                <div class="w-10 h-10 border-4 border-orange-200 border-t-orange-500 rounded-full animate-spin"></div>
                <p class="text-gray-500 mt-4 font-medium animate-pulse">Loading menu...</p>
            </div>
        </div>

    </div>

    <!-- Floating Table Status (If Active) -->
    <!-- Status Banner (Removed - buttons moved to cart modal) -->


    <!-- Cart Floating Bar -->
    <div id="cart-bar" onclick="openCart()"
        class="hidden fixed bottom-6 left-1/2 transform -translate-x-1/2 w-[90%] max-w-md glass-panel bg-gray-900/95 text-white shadow-2xl rounded-full p-2 z-50 cursor-pointer transition-all duration-200 hover:scale-[1.02] active:scale-[0.98] ring-1 ring-white/20 flex items-center justify-between pr-5 pl-2 backdrop-blur-xl">
        <div class="flex items-center gap-3">
            <div
                class="bg-orange-500 text-white w-10 h-10 rounded-full flex items-center justify-center font-bold text-sm shadow-lg shadow-orange-500/30 cart-count transition-transform transform scale-100">
                0</div>
            <div class="flex flex-col">
                <span
                    class="text-[10px] font-bold text-gray-400 uppercase tracking-wider leading-none mb-0.5 cart-label">Total</span>
                <span class="text-lg font-bold text-white leading-none cart-total">‚Çπ0</span>
            </div>
        </div>
        <div class="flex items-center gap-2 font-bold text-sm text-white">
            <span class="cart-action-text">View Cart</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
        </div>
    </div>

    <!-- Cart Modal -->
    <div id="cart-modal"
        class="fixed inset-0 z-[60] hidden flex flex-col justify-end md:justify-center md:items-center pointer-events-none">
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm pointer-events-auto transition-opacity duration-300"
            onclick="closeCart()"></div>
        <div
            class="relative w-full md:w-[95%] md:max-w-md bg-white rounded-t-3xl md:rounded-3xl shadow-2xl flex flex-col max-h-[90vh] animate-slide-up transform transition-transform overflow-hidden pointer-events-auto">

            <!-- Header -->
            <div class="p-5 border-b border-gray-100 bg-white z-10">
                <div class="flex items-center justify-between mb-3">
                    <div>
                        <h2 class="text-2xl font-bold text-gray-900 font-display">Your Order</h2>
                        <p class="text-sm text-gray-500">Review before requesting</p>
                    </div>
                    <button onclick="closeCart()" class="p-2 bg-gray-50 rounded-full hover:bg-gray-100 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-500" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Content -->
            <div class="flex-1 overflow-y-auto p-5 custom-scrollbar">

                <!-- Existing Table Order (Read Only) -->
                <div id="existing-order-section"
                    class="hidden mb-6 border border-green-100 bg-green-50/50 rounded-2xl p-4">
                    <h3 class="font-bold text-green-800 text-sm uppercase tracking-wide mb-3 flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        Already Ordered
                    </h3>
                    <div id="existing-items-list" class="space-y-2 text-sm text-gray-700"></div>
                </div>

                <!-- New Items -->
                <div id="cart-items-list" class="space-y-4"></div>

                <!-- Guest Form -->
                <div class="pt-6 mt-6 border-t border-gray-100 space-y-4">
                    <h3 class="font-bold text-gray-900 text-sm uppercase tracking-wide">Guest Details <span
                            class="font-normal text-gray-400 capitalize">(Optional)</span></h3>
                    <input type="text" id="guest-name" placeholder="Your Name"
                        class="w-full px-4 py-3 rounded-xl bg-gray-50 border-none focus:ring-2 focus:ring-orange-200 text-gray-900 placeholder-gray-400 font-medium text-sm">
                    <input type="tel" id="guest-phone" placeholder="Phone Number"
                        class="w-full px-4 py-3 rounded-xl bg-gray-50 border-none focus:ring-2 focus:ring-orange-200 text-gray-900 placeholder-gray-400 font-medium text-sm">
                </div>
            </div>

            <!-- Footer -->
            <div class="p-5 border-t border-gray-100 bg-gray-50 rounded-b-3xl space-y-3">
                <!-- Cancel Request Button (shown when pending request exists) -->
                <button id="cancel-req-btn" onclick="cancelPendingRequest()"
                    class="hidden w-full py-3 bg-red-50 text-red-700 rounded-xl font-bold text-base border-2 border-red-200 shadow-sm hover:bg-red-100 active:scale-[0.98] transition-all">
                    Cancel Request
                </button>
                
                <button id="place-order-btn" onclick="submitOrder()"
                    class="w-full py-3.5 bg-gray-900 text-white rounded-xl font-bold text-lg shadow-lg shadow-gray-900/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2">
                    <span>Send Order Request</span>
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Order Config Dialog -->
    <div id="confirm-dialog" class="fixed inset-0 z-[80] hidden items-center justify-center p-4">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-sm animate-fade-in"></div>
        <div class="relative bg-white rounded-3xl p-6 w-full max-w-sm shadow-2xl animate-slide-up text-center">
            <div
                class="w-16 h-16 bg-green-100 text-green-600 rounded-full flex items-center justify-center mx-auto mb-4 text-3xl">
                üéâ</div>
            <h3 class="text-xl font-bold text-gray-900 mb-2">Request Sent!</h3>
            <p class="text-gray-500 text-sm mb-6">Staff will review your request shortly. You can add more items to this
                order anytime.</p>
            <button onclick="closeConfirmDialog()" class="w-full py-3 bg-gray-900 text-white rounded-xl font-bold">Okay,
                Got it</button>
        </div>
    </div>


    <script>
        // State
        const state = {
            tenantId: new URLSearchParams(window.location.search).get('tenant_id'),
            tableId: new URLSearchParams(window.location.search).get('table_id') || new URLSearchParams(window.location.search).get('room_id'),
            hallId: new URLSearchParams(window.location.search).get('hall_id') || (new URLSearchParams(window.location.search).get('room_id') ? 'ROOM_SERVICE' : null),
            items: [],
            itemsMap: {},
            cart: {}, // { code: { qty: 1, item: ... } }
            existingOrder: null,
            pendingRequest: null, // NEW: Store pending request
            isEditingPendingRequest: false, // Flag to prevent overwriting user edits
            cartModifiedFromPending: false, // Track if cart has been modified from original pending request
            filter: { category: 'All', search: '' },
            settings: {}
        };

        // ... Configuration ... (Same as before)
        const IS_LOCAL = true;
        const PROD_LAMBDA_URL = "https://ydhettu7l6.execute-api.ap-south-1.amazonaws.com/production/api/guest/order/request";
        const LAMBDA_URL = IS_LOCAL ? 'http://localhost:3001/api/guest/lambda' : PROD_LAMBDA_URL;

        // ... Initialization ... 

        async function init() {
            if (!state.tenantId) {
                document.body.innerHTML = '<div class="p-10 text-center">Missing Tenant ID</div>';
                return;
            }

            try {
                // 1. Fetch Guest Settings (via Lambda/Sim)
                // Appending path for Proxy: /settings
                const settingsRes = await axios.get(`${LAMBDA_URL}/settings?tenant_id=${state.tenantId}`);
                state.settings = settingsRes.data.settings;
                renderHeader();

                // 2. Fetch Items (Default GET to Lambda/Sim)
                const menuRes = await axios.get(`${LAMBDA_URL}?tenant_id=${state.tenantId}`);
                state.items = menuRes.data.items || menuRes.data; // Handle {items: []} or raw []
                state.itemsMap = state.items.reduce((acc, item) => { acc[item.item_code] = item; return acc; }, {});
                

                renderMenu();

                // 3. Initial Table Status Check (via Lambda/Sim)
                if (state.tableId && state.hallId) {
                    await checkTableStatus();
                    // Poll status every 5s
                    setInterval(checkTableStatus, 5000);
                } else {
                    // Update cart summary even if no table status check
                    updateCartSummaryTop();
                }

            } catch (err) {
                console.error(err);
                document.getElementById('items-container').innerHTML =
                    '<div class="text-center py-20 text-red-500">Failed to load menu. Please scan again.</div>';
            }
        }

        function renderHeader() {
            const header = document.getElementById('restaurant-header');
            const { restaurant_name, restaurant_address, phone_no } = state.settings;
            console.log("restaurant_address", restaurant_address)

            // Format address handling string vs object
            let formattedAddress = "";
            if (restaurant_address) {
                if (typeof restaurant_address === 'string') {
                    formattedAddress = restaurant_address;
                } else if (typeof restaurant_address === 'object') {
                    formattedAddress = [
                        restaurant_address.address_line_1,
                        restaurant_address.address_line_2,
                        restaurant_address.city,
                        restaurant_address.pincode
                    ].filter(part => part && String(part).trim() !== '').join(', ');
                }
            }

            header.innerHTML = `
                <div class="inline-flex items-center justify-center w-12 h-12 bg-white rounded-2xl shadow-sm mb-4 text-2xl">üçΩÔ∏è</div>
                <h1 class="text-2xl md:text-3xl font-bold text-gray-900 mb-1 font-display tracking-tight">${restaurant_name}</h1>
                <p class="text-gray-500 font-medium text-xs md:text-sm tracking-wide uppercase max-w-md mx-auto leading-relaxed">
                    ${formattedAddress} ${phone_no ? ' ‚Ä¢ ' + phone_no : ''}
                </p>
            `;
        }

        // --- Updated Check Table Status ---
        async function checkTableStatus() {
            try {
                const res = await axios.get(`${LAMBDA_URL}/table/status`, {
                    params: { tenant_id: state.tenantId, table_id: state.tableId, hall_id: state.hallId }
                });

                if (res.data.success) {
                    const prevPendingId = state.pendingRequest ? state.pendingRequest.request_id : null;

                    // 1. Pending Request Handling
                    const hasPendingRequestInResponse = res.data.active_order && res.data.active_order.pending_request;
                    const hasActiveOrderItems = res.data.active_order && res.data.active_order.items && res.data.active_order.items.length > 0;
                    
                    // Check if pending request was approved (had pending before, now it's gone and order exists)
                    const wasPendingApproved = prevPendingId && !hasPendingRequestInResponse && hasActiveOrderItems;
                    
                    if (hasPendingRequestInResponse) {
                        // There's still a pending request
                        const newPendingId = res.data.active_order.pending_request.request_id;
                        const isNewPendingRequest = !state.pendingRequest || state.pendingRequest.request_id !== newPendingId;
                        
                        if (!state.isEditingPendingRequest && !state.cartModifiedFromPending) {
                            // Only update cart if this is a new pending request or cart hasn't been modified
                            if (isNewPendingRequest || !state.cartModifiedFromPending) {
                                state.pendingRequest = res.data.active_order.pending_request;
                                
                                // Populate cart with pending items to show quantity buttons
                                state.cart = {};
                                state.pendingRequest.items.forEach(pi => {
                                    const originalItem = state.itemsMap[pi.item_code] || pi;
                                    state.cart[pi.item_code] = {
                                        qty: pi.quantity,
                                        item: originalItem
                                    };
                                });
                                
                                // Reset modification flag when we sync from server
                                state.cartModifiedFromPending = false;
                                
                                // Update UI to reflect pending quantities
                                updateCartBarUI();
                                updateMenuQuantitiesOnly();
                            } else {
                                // Just update the pendingRequest object, don't touch cart
                                state.pendingRequest = res.data.active_order.pending_request;
                            }
                        } else {
                            // User is editing - just update the pendingRequest object, don't touch cart
                            state.pendingRequest = res.data.active_order.pending_request;
                        }
                    } else if (wasPendingApproved || (!hasPendingRequestInResponse && prevPendingId)) {
                        // Pending request was approved or removed - clear it
                        // Clear cart if it only contains items from the previous pending request
                        const cartItemCodes = Object.keys(state.cart);
                        const prevPendingItemCodes = state.pendingRequest ? 
                            (state.pendingRequest.items?.map(i => i.item_code) || []) : [];
                        const isCartOnlyPendingItems = cartItemCodes.length > 0 && 
                                                      prevPendingItemCodes.length > 0 &&
                                                      cartItemCodes.every(code => prevPendingItemCodes.includes(code)) &&
                                                      cartItemCodes.length === prevPendingItemCodes.length;
                        
                        if (isCartOnlyPendingItems) {
                            state.cart = {};
                            updateCartBarUI();
                            updateMenuQuantitiesOnly();
                            updateCartSummaryTop();
                        }
                        
                        // Clear pending request state
                        state.pendingRequest = null;
                        state.isEditingPendingRequest = false;
                        state.cartModifiedFromPending = false;
                    }

                    // 2. Active Order (Confirmed)
                    // If search returns active_order with items, those are confirmed items
                    if (res.data.active_order && res.data.active_order.items) {
                        state.existingOrder = res.data.active_order;
                    } else {
                        state.existingOrder = null;
                    }

                    // 3. Update UI Components

                    // If the modal is OPEN, refresh it effectively immediately
                    if (!document.getElementById('cart-modal').classList.contains('hidden')) {
                        renderCartModalItems();
                    }

                    updateStatusUI();
                    
                    // Update cart bar to show when approved order exists
                    updateCartBarUI();
                    
                    // Update cancel button in cart modal even when closed
                    const cancelBtn = document.getElementById('cancel-req-btn');
                    if (cancelBtn) {
                        if (state.pendingRequest) {
                            cancelBtn.classList.remove('hidden');
                        } else {
                            cancelBtn.classList.add('hidden');
                        }
                    }
                }
            } catch (e) {
                console.log("Table status check failed silently", e);
            }
        }

        function updateStatusUI() {
            // Status banner removed - cancel button is now in cart modal footer
            // Update cancel button visibility in cart modal footer
            const cancelBtn = document.getElementById('cancel-req-btn');
            if (cancelBtn) {
                if (state.pendingRequest) {
                    cancelBtn.classList.remove('hidden');
                } else {
                    cancelBtn.classList.add('hidden');
                }
            }
        }

        window.cancelPendingRequest = async () => {
            if (!confirm('Are you sure you want to cancel your request?')) return;

            const btn = document.getElementById('cancel-req-btn');
            if (btn) btn.innerHTML = '...';

            try {
                const res = await axios.delete(`${LAMBDA_URL}/request`, {
                    data: {
                        tenant_id: state.tenantId,
                        request_id: state.pendingRequest.request_id
                    }
                });

                if (res.data.success) {
                    // Clear pending request and cart immediately
                    state.pendingRequest = null;
                    state.isEditingPendingRequest = false;
                    state.cartModifiedFromPending = false;
                    
                    // Clear cart to remove quantity buttons (revert to "ADD" buttons)
                    state.cart = {};
                    updateCartBarUI();
                    updateMenuQuantitiesOnly();
                    
                    // Refresh status to sync with backend
                    checkTableStatus();
                } else {
                    alert('Failed to cancel request');
                }
            } catch (e) {
                console.error(e);
                alert('Connection error');
            }
        };

        window.editPendingRequest = () => {
            if (!state.pendingRequest) return;

            // Set flag to prevent polling from overwriting edits
            state.isEditingPendingRequest = true;

            // Cart is already populated from checkTableStatus, but ensure it's synced
            // This allows user to modify quantities
            state.pendingRequest.items.forEach(pi => {
                const originalItem = state.itemsMap[pi.item_code] || pi;
                // Only update if not already in cart (preserve any user modifications)
                if (!state.cart[pi.item_code]) {
                    state.cart[pi.item_code] = {
                        qty: pi.quantity,
                        item: originalItem
                    };
                }
            });

            // Reset modification flag when entering edit mode
            state.cartModifiedFromPending = false;

            updateCartBarUI();
            updateMenuQuantitiesOnly();
            updateCartSummaryTop(); // Update top summary when entering edit mode
            openCart();
        };

        window.updateMenuQuantitiesOnly = () => {
            state.items.forEach(item => {
                const qty = state.cart[item.item_code]?.qty || 0;
                const wrapper = document.getElementById(`qty-wrapper-${item.item_code}`);
                if (wrapper) {
                    wrapper.innerHTML = getQtyButtonHTML(item.item_code, item.sold_out);
                }
            });
        };

        // --- Core Rendering (optimized) ---

        let isMenuRendered = false;

        function renderMenu(forceRebuild = false) {
            const container = document.getElementById('items-container');

            // Initial Build
            if (!isMenuRendered || forceRebuild) {
                container.innerHTML = "";

                // Grouping
                const grouped = {};
                state.items.forEach(item => {
                    const cat = item.category || 'Other';
                    if (!grouped[cat]) grouped[cat] = [];
                    grouped[cat].push(item);
                });

                // Render Groups
                Object.entries(grouped).forEach(([category, items]) => {
                    const section = document.createElement('div');
                    section.className = 'w-full scroll-mt-32';
                    section.id = `cat-${category.replace(/\s+/g, '-')}`;
                    section.dataset.category = category; // Data attribute for filtering

                    const title = document.createElement('h2');
                    title.className = 'text-xl font-bold text-gray-800 mb-4 sticky top-0 bg-gray-50/95 backdrop-blur-sm p-2 z-10 flex items-center';
                    title.innerHTML = `<span class="w-1 h-5 bg-orange-500 rounded-full mr-3"></span>${category}`;
                    section.appendChild(title);

                    const grid = document.createElement('div');
                    grid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';

                    items.forEach(item => {
                        const el = createItemCard(item);
                        grid.appendChild(el);
                    });

                    section.appendChild(grid);
                    container.appendChild(section);
                });

                renderCategories();
                isMenuRendered = true;
            }

            // Filtering (Visibility Toggle)
            const searchQuery = state.filter.search ? state.filter.search.toLowerCase() : "";
            const selectedCat = state.filter.category;

            let hasVisibleItems = false;

            // Iterate through all sections
            const sections = container.querySelectorAll('[id^="cat-"]');
            sections.forEach(section => {
                const category = section.dataset.category;
                const items = section.querySelectorAll('[id^="card-"]');
                let visibleItemsInSection = 0;

                items.forEach(card => {
                    // Extract data from custom attributes or rebuild lookup
                    // For simplicity, we can store name/cat on the card itself or lookup via ID
                    const itemCode = card.id.replace('card-', '');
                    const item = state.itemsMap[itemCode]; // Ensure we have a map

                    if (!item) return;

                    const matchSearch = !searchQuery || item.name.toLowerCase().includes(searchQuery);
                    const matchCat = selectedCat === 'All' || item.category === selectedCat;

                    if (matchSearch && matchCat) {
                        card.classList.remove('hidden');
                        visibleItemsInSection++;
                        hasVisibleItems = true;
                    } else {
                        card.classList.add('hidden');
                    }
                });

                // Hide section if no items visible
                if (visibleItemsInSection === 0) {
                    section.classList.add('hidden');
                } else {
                    section.classList.remove('hidden');
                }
            });

            // Show/Hide "No Items" msg
            let noItemsMsg = document.getElementById('no-items-msg');
            if (!hasVisibleItems) {
                if (!noItemsMsg) {
                    noItemsMsg = document.createElement('div');
                    noItemsMsg.id = 'no-items-msg';
                    noItemsMsg.className = 'text-center py-20 text-gray-400';
                    noItemsMsg.textContent = 'No items found';
                    container.appendChild(noItemsMsg);
                }
                noItemsMsg.classList.remove('hidden');
            } else if (noItemsMsg) {
                noItemsMsg.classList.add('hidden');
            }
        }

        function createItemCard(item) {
            const div = document.createElement('div');
            const isSoldOut = item.sold_out;
            const imgUrl = `https://digikhana-production.s3.amazonaws.com/item/${state.tenantId}/${item.item_code}.jpg`;

            // Using a Key for easy DOM update lookup
            div.id = `card-${item.item_code}`;
            
            // Make card clickable (except when sold out)
            if (!isSoldOut) {
                div.style.cursor = 'pointer';
                div.onclick = (e) => {
                    // Don't trigger if clicking on quantity buttons
                    if (!e.target.closest(`#qty-wrapper-${item.item_code}`)) {
                        updateCart(item.item_code, 1);
                    }
                };
            }

            div.className = `bg-white rounded-2xl p-4 shadow-sm border border-gray-100 flex gap-4 ${isSoldOut ? 'opacity-60' : 'hover:shadow-md transition-shadow'} ${!isSoldOut ? 'cursor-pointer' : ''}`;

            div.innerHTML = `
                <div class="h-24 w-24 flex-shrink-0 rounded-xl bg-gray-100 overflow-hidden relative">
                     <img src="${imgUrl}" class="w-full h-full object-cover" 
                          onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22 viewBox=%220 0 100 100%22><rect width=%22100%22 height=%22100%22 fill=%22%23eee%22/><text x=%2250%22 y=%2250%22 font-family=%22Arial%22 font-size=%2220%22 fill=%22%23bbb%22 text-anchor=%22middle%22 dy=%22.3em%22>No Image</text></svg>'">
                     ${isSoldOut ? '<div class="absolute inset-0 bg-black/50 flex items-center justify-center text-white text-[10px] font-bold">SOLD OUT</div>' : ''}
                </div>
                <div class="flex-1 flex flex-col justify-between">
                    <div>
                        <div class="flex justify-between items-start">
                             <h3 class="font-bold text-gray-900 leading-tight mb-1 text-[15px]">${item.name}</h3>
                             ${item.is_veg === true ? '<div class="w-3 h-3 border border-green-600 flex items-center justify-center p-[1px] rounded-[2px] ml-1"><div class="w-1.5 h-1.5 bg-green-600 rounded-full"></div></div>' : (item.is_veg === false ? '<div class="w-3 h-3 border border-red-600 flex items-center justify-center p-[1px] rounded-[2px] ml-1"><div class="w-1.5 h-1.5 bg-red-600 rounded-full"></div></div>' : '')}
                        </div>
                        <p class="font-bold text-gray-900 text-sm">‚Çπ${item.price}</p>
                    </div>
                    
                    <div class="flex justify-end mt-2" id="qty-wrapper-${item.item_code}" onclick="event.stopPropagation()">
                        <!-- Injected by updateItemQtyUI -->
                        ${getQtyButtonHTML(item.item_code, isSoldOut)}
                    </div>
                </div>
            `;
            return div;
        }

        function getQtyButtonHTML(code, isSoldOut) {
            if (isSoldOut) return `<button disabled class="text-xs font-bold text-gray-400 bg-gray-100 px-3 py-1.5 rounded-lg cursor-not-allowed">Sold Out</button>`;

            const qty = state.cart[code]?.qty || 0;
            if (qty === 0) {
                // Always allow adding items
                return `<button onclick="updateCart('${code}', 1)" class="bg-orange-50 text-orange-600 font-extrabold text-xs px-5 py-2 rounded-xl shadow-sm border border-orange-100 active:bg-orange-100 uppercase tracking-wide">ADD</button>`;
            } else {
                // Always show editable quantity controls
                return `
                    <div class="flex items-center bg-gray-900 text-white rounded-lg shadow-md h-8">
                        <button onclick="updateCart('${code}', -1)" class="w-8 h-full flex items-center justify-center font-bold text-lg hover:bg-white/10 active:bg-white/20 rounded-l-lg">-</button>
                        <span class="w-6 text-center font-bold text-sm">${qty}</span>
                        <button onclick="updateCart('${code}', 1)" class="w-8 h-full flex items-center justify-center font-bold text-lg hover:bg-white/10 active:bg-white/20 rounded-r-lg">+</button>
                    </div>
                `;
            }
        }

        function renderCategories() {
            const container = document.getElementById('category-chips');
            // Get unique cats
            const cats = ['All', ...new Set(state.items.map(i => i.category || 'Other'))];
            container.innerHTML = cats.map(cat => {
                // Ensure strict comparison works by trimming or handling potential type issues if any
                const isActive = state.filter.category === cat;
                return `
                <button onclick="setCategory('${cat.replace(/'/g, "\\'")}')" 
                    class="category-chip px-4 py-1.5 rounded-full text-sm font-semibold whitespace-nowrap transition-all border ${isActive ? 'bg-gray-900 text-white border-gray-900 shadow-md' : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'}">
                    ${cat}
                </button>
            `}).join('');
        }



        // --- Interaction ---

        window.updateCart = (itemCode, change, allowFromTopView = false) => {
            // If pending request exists and not in edit mode, enable edit mode automatically
            // This allows editing from anywhere (menu items, cart summary, cart modal)
            if (state.pendingRequest && !state.isEditingPendingRequest) {
                state.isEditingPendingRequest = true;
            }

            // If item is not in cart, and we're trying to decrement, do nothing
            if (!state.cart[itemCode] && change < 0) return;

            // If item is not in cart, and we're trying to increment, add it
            if (!state.cart[itemCode] && change > 0) {
                const item = state.items.find(i => i.item_code === itemCode);
                if (item) {
                    state.cart[itemCode] = { qty: 0, item: item };
                } else {
                    console.warn(`Item with code ${itemCode} not found.`);
                    return;
                }
            }

            state.cart[itemCode].qty += change;

            if (state.cart[itemCode].qty <= 0) {
                delete state.cart[itemCode];
            }

            // Mark cart as modified if we're editing a pending request
            if (state.pendingRequest && state.isEditingPendingRequest) {
                state.cartModifiedFromPending = true;
            }

            // Update UI
            updateCartBarUI();
            updateMenuQuantitiesOnly(); // Optimized UI update
            updateCartSummaryTop(); // Update cart summary at top

            // If cart modal is open, re-render it
            if (!document.getElementById('cart-modal').classList.contains('hidden')) {
                renderCartModalItems();
            }
        };

        window.updateCartBarUI = () => {
            const bar = document.getElementById('cart-bar');
            const items = Object.values(state.cart);
            
            // Show cart bar if there are items OR if there's an approved order (so user can view/add items)
            const hasItems = items.length > 0;
            const hasApprovedOrder = state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0;
            
            if (!hasItems && !hasApprovedOrder) {
                bar.classList.add('hidden');
                return;
            }

            bar.classList.remove('hidden');

            // Calculate totals
            const totalQty = items.reduce((acc, c) => acc + c.qty, 0);
            const totalPrice = items.reduce((acc, c) => acc + (c.item.price * c.qty), 0);
            
            // If no items but approved order exists, show approved order info
            if (hasItems) {
                bar.querySelector('.cart-count').innerText = totalQty;
                bar.querySelector('.cart-total').innerText = '‚Çπ' + totalPrice;
                const cartLabel = bar.querySelector('.cart-label');
                const cartAction = bar.querySelector('.cart-action-text');
                if (cartLabel) cartLabel.textContent = 'Total';
                if (cartAction) cartAction.textContent = 'View Cart';
            } else if (hasApprovedOrder) {
                // Show approved order info
                const approvedQty = state.existingOrder.items.reduce((sum, i) => sum + (i.quantity || 0), 0);
                const approvedTotal = state.existingOrder.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0);
                bar.querySelector('.cart-count').innerText = approvedQty;
                bar.querySelector('.cart-total').innerText = '‚Çπ' + approvedTotal;
                const cartLabel = bar.querySelector('.cart-label');
                const cartAction = bar.querySelector('.cart-action-text');
                if (cartLabel) cartLabel.textContent = 'Order Total';
                if (cartAction) cartAction.textContent = 'View Order';
            }
            
            // Also update cart summary at top
            updateCartSummaryTop();
        };

        window.updateCartSummaryTop = () => {
            const summaryContainer = document.getElementById('cart-summary-top');
            const itemsContainer = document.getElementById('cart-summary-items');
            const totalContainer = document.getElementById('cart-summary-total');
            const totalAmountEl = document.getElementById('cart-summary-total-amount');
            const items = Object.values(state.cart);

            if (items.length === 0) {
                summaryContainer.classList.add('hidden');
                totalContainer.classList.add('hidden');
                return;
            }

            summaryContainer.classList.remove('hidden');
            totalContainer.classList.remove('hidden');

            // Calculate total
            const totalPrice = items.reduce((acc, c) => acc + (c.item.price * c.qty), 0);
            totalAmountEl.textContent = '‚Çπ' + totalPrice;

            // Always allow editing from top view - this is the primary editing location
            // Show max 5 items, with "and X more" if needed
            const maxVisible = 5;
            const visibleItems = items.slice(0, maxVisible);
            const remainingCount = items.length - maxVisible;

            itemsContainer.innerHTML = visibleItems.map(({ qty, item }) => `
                <div class="flex items-center justify-between py-2 border-b border-gray-50 last:border-0">
                    <div class="flex-1 min-w-0">
                        <div class="font-semibold text-gray-900 text-sm truncate">${item.name}</div>
                        <div class="text-orange-600 font-bold text-xs">‚Çπ${item.price * qty}</div>
                    </div>
                    <div class="flex items-center bg-gray-100 rounded-lg h-7 ml-3">
                        <button onclick="updateCart('${item.item_code}', -1, true)" class="w-7 h-full flex items-center justify-center font-bold text-gray-600 text-sm hover:bg-gray-200 active:bg-gray-300 transition-colors">-</button>
                        <span class="w-5 text-center font-bold text-xs text-gray-900">${qty}</span>
                        <button onclick="updateCart('${item.item_code}', 1, true)" class="w-7 h-full flex items-center justify-center font-bold text-gray-900 text-sm hover:bg-gray-200 active:bg-gray-300 transition-colors">+</button>
                    </div>
                </div>
            `).join('') + (remainingCount > 0 ? `
                <div class="text-center py-2 text-sm text-gray-500 font-medium">
                    and ${remainingCount} more item${remainingCount > 1 ? 's' : ''}
                </div>
            ` : '');
        };

        // --- Interaction ---

        window.handleSearch = (val) => {
            state.filter.search = val.toLowerCase();
            document.getElementById('clear-search-btn').classList.toggle('hidden', val.length === 0);
            renderMenu();
        };

        window.clearSearch = () => {
            document.getElementById('search-input').value = '';
            handleSearch('');
        };

        window.setCategory = (cat) => {
            state.filter.category = cat;
            renderCategories(); // Update category chips to reflect new selection
            renderMenu();
        };

        // --- Cart Modal ---

        window.openCart = (fromStatusBanner = false) => {
            // Enable edit mode when opening cart modal (allows editing from modal)
            // Also enable if opening from status banner "View" button
            if (state.pendingRequest && (fromStatusBanner || !state.isEditingPendingRequest)) {
                state.isEditingPendingRequest = true;
                state.cartModifiedFromPending = false;
            }
            
            document.getElementById('cart-modal').classList.remove('hidden');
            renderCartModalItems();
            document.body.style.overflow = 'hidden';
        };

        window.closeCart = () => {
            document.getElementById('cart-modal').classList.add('hidden');
            document.body.style.overflow = 'auto';
            // Don't clear editing flag if cart has been modified - preserve user edits
            // Only clear if cart is empty or user explicitly wants to cancel
            if (Object.keys(state.cart).length === 0) {
                state.isEditingPendingRequest = false;
                state.cartModifiedFromPending = false;
            }
            // Update menu to reflect current state (read-only if pending exists)
            updateMenuQuantitiesOnly();
            updateCartSummaryTop(); // Update cart summary when modal closes
        };

        // --- Updated Cart Modal Rendering ---

        function renderCartModalItems() {
            const container = document.getElementById('cart-items-list');
            const submitBtn = document.getElementById('place-order-btn');
            const cancelBtn = document.getElementById('cancel-req-btn');

            const existingSection = document.getElementById('existing-order-section');
            const existingList = document.getElementById('existing-items-list');
            
            // Update cancel button visibility
            if (cancelBtn) {
                if (state.pendingRequest) {
                    cancelBtn.classList.remove('hidden');
                } else {
                    cancelBtn.classList.add('hidden');
                }
            }
            
            // Update submit button state
            const canEdit = !state.pendingRequest || state.isEditingPendingRequest;
            if (state.pendingRequest && !state.isEditingPendingRequest) {
                // Disable submit button when pending request exists but not in edit mode
                submitBtn.disabled = true;
                submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
                submitBtn.innerHTML = `<span>Use "Edit Order" to modify</span>`;
            } else {
                submitBtn.disabled = false;
                submitBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                submitBtn.innerHTML = `<span>Send Order Request</span> <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>`;
            }

            // 1. Pending Items Section (NEW)
            let pendingSection = document.getElementById('pending-order-section');
            if (!pendingSection) {
                pendingSection = document.createElement('div');
                pendingSection.id = 'pending-order-section';
                pendingSection.className = 'hidden mb-4 border border-orange-200 bg-orange-50/50 rounded-2xl p-4';
                pendingSection.innerHTML = `
                    <h3 class="font-bold text-orange-800 text-sm uppercase tracking-wide mb-3 flex items-center gap-2">
                        <span class="w-2 h-2 bg-orange-500 rounded-full animate-pulse"></span>
                         Waiting for Approval
                    </h3>
                    <div id="pending-items-list" class="space-y-2 text-sm text-gray-700"></div>
                `;
                // Insert before existing section if possible, else append
                if (existingSection && existingSection.parentNode) {
                    existingSection.parentNode.insertBefore(pendingSection, existingSection);
                }
            }

            // Hide pending section - items will be shown in cart with editable quantities
            if (pendingSection) {
                pendingSection.classList.add('hidden');
            }

            // 2. Existing "On Table" Items (Approved Order)
            if (state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0) {
                existingSection.classList.remove('hidden');
                
                // Calculate approved order total
                const approvedTotal = state.existingOrder.items.reduce((sum, i) => {
                    return sum + ((i.price || 0) * (i.quantity || 0));
                }, 0);
                
                existingList.innerHTML = state.existingOrder.items.map(i => `
                    <div class="flex justify-between items-center py-1">
                        <span class="flex items-center gap-2"><span class="w-1.5 h-1.5 bg-green-500 rounded-full"></span> ${i.name}</span>
                        <span class="font-bold text-gray-500">x${i.quantity}</span>
                    </div>
                    `).join('') + `
                    <div class="flex justify-between items-center pt-2 mt-2 border-t border-green-200">
                        <span class="font-bold text-green-800 text-sm">Approved Total:</span>
                        <span class="font-bold text-green-800 text-sm">‚Çπ${approvedTotal}</span>
                    </div>
                `;
            } else {
                existingSection.classList.add('hidden');
            }

            // 3. Current Cart - Show all items (pending + new) with editable quantities
            // Create a map of pending request quantities for reference
            const pendingQuantities = {};
            if (state.pendingRequest && state.pendingRequest.items) {
                state.pendingRequest.items.forEach(i => {
                    pendingQuantities[i.item_code] = i.quantity || 0;
                });
            }
            
            // Merge pending items into cart if they're not already there
            // This ensures all pending items are visible and editable
            if (state.pendingRequest && state.pendingRequest.items) {
                state.pendingRequest.items.forEach(pi => {
                    const originalItem = state.itemsMap[pi.item_code] || pi;
                    // Only add if not already in cart (preserve any user modifications)
                    if (!state.cart[pi.item_code]) {
                        state.cart[pi.item_code] = {
                            qty: pi.quantity,
                            item: originalItem
                        };
                    }
                });
            }
            
            // Recalculate entries after merging
            const allEntries = Object.entries(state.cart);
            
            // Calculate totals
            // Cart total: count only the difference in quantities (increases) as new items
            const cartTotal = allEntries.reduce((sum, [code, { qty, item }]) => {
                const pendingQty = pendingQuantities[code] || 0;
                const newQty = Math.max(0, qty - pendingQty); // Only count the increase
                return sum + (item.price * newQty);
            }, 0);
            
            // Pending total: original pending quantities
            const pendingTotal = state.pendingRequest && state.pendingRequest.items ? 
                state.pendingRequest.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0) : 0;
            
            // Show all items in cart (pending + new)
            // If cart is empty but there's an approved order, show helpful message
            if (allEntries.length === 0) {
                if (state.existingOrder && state.existingOrder.items && state.existingOrder.items.length > 0) {
                    container.innerHTML = `
                        <div class="text-center py-8">
                            <div class="text-gray-400 text-sm mb-2">Your approved order is shown above</div>
                            <div class="text-gray-500 text-xs">Add more items to your order below</div>
                        </div>
                    `;
                } else {
                    container.innerHTML = '<div class="text-center py-8 text-gray-400 text-sm">No items in cart</div>';
                }
            } else {
                container.innerHTML = allEntries.map(([code, { qty, item }]) => {
                    const pendingQty = pendingQuantities[code] || 0;
                    const isPendingItem = pendingQty > 0;
                    const newQty = Math.max(0, qty - pendingQty);
                    
                    return `
                    <div class="flex items-center justify-between py-3 border-b border-gray-50 last:border-0 ${isPendingItem ? 'bg-orange-50/30' : ''}">
                        <div class="flex-1">
                            <div class="flex items-center gap-2">
                                <div class="font-bold text-gray-900 text-[15px]">${item.name}</div>
                                ${isPendingItem ? `
                                <span class="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded-full font-semibold">Pending</span>
                                ` : ''}
                            </div>
                            ${isPendingItem && newQty > 0 ? `
                            <div class="text-xs text-gray-500 mb-1">+${newQty} more added</div>
                            ` : ''}
                            <div class="text-orange-600 font-bold text-xs">‚Çπ${item.price * qty}</div>
                        </div>
                        ${canEdit ? `
                        <div class="flex items-center bg-gray-100 rounded-lg h-8">
                            <button onclick="updateCart('${code}', -1, true)" class="w-8 h-full flex items-center justify-center font-bold text-gray-600">-</button>
                            <span class="w-6 text-center font-bold text-sm text-gray-900">${qty}</span>
                            <button onclick="updateCart('${code}', 1, true)" class="w-8 h-full flex items-center justify-center font-bold text-gray-900">+</button>
                        </div>
                        ` : `
                        <div class="flex items-center bg-gray-200 rounded-lg h-8 px-3">
                            <span class="text-center font-bold text-sm text-gray-600">${qty}</span>
                        </div>
                        `}
                    </div>
                    `;
                }).join('') + `
                    ${allEntries.length > 0 ? `
                    <div class="flex justify-between items-center pt-3 mt-3 border-t border-gray-200">
                        <span class="font-bold text-gray-900 text-sm">Cart Total:</span>
                        <span class="font-bold text-orange-600 text-sm">‚Çπ${Object.values(state.cart).reduce((sum, { qty, item }) => sum + (item.price * qty), 0)}</span>
                    </div>
                    ${pendingTotal > 0 ? `
                    <div class="flex justify-between items-center pt-2 text-xs">
                        <span class="text-gray-500">Pending Order:</span>
                        <span class="text-orange-600 font-semibold">‚Çπ${pendingTotal}</span>
                    </div>
                    <div class="flex justify-between items-center pt-1 text-xs">
                        <span class="text-gray-500">New Items:</span>
                        <span class="text-orange-600 font-semibold">‚Çπ${cartTotal}</span>
                    </div>
                    ` : ''}
                    ` : ''}
                `;
            }
            
            // 4. Combined Total Section
            let combinedTotalSection = document.getElementById('combined-total-section');
            if (!combinedTotalSection) {
                combinedTotalSection = document.createElement('div');
                combinedTotalSection.id = 'combined-total-section';
                combinedTotalSection.className = 'mt-4 pt-4 border-t-2 border-gray-300';
                // Insert before guest form
                const guestForm = document.querySelector('.pt-6.mt-6.border-t');
                if (guestForm && guestForm.parentNode) {
                    guestForm.parentNode.insertBefore(combinedTotalSection, guestForm);
                }
            }
            
            // Calculate all totals for combined section
            // Recalculate pending total (original pending quantities)
            const pendingTotalForCombined = state.pendingRequest && state.pendingRequest.items ? 
                state.pendingRequest.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0) : 0;
            const approvedTotal = state.existingOrder && state.existingOrder.items ? 
                state.existingOrder.items.reduce((sum, i) => sum + ((i.price || 0) * (i.quantity || 0)), 0) : 0;
            // cartTotal is the new items total (quantity increases only)
            const grandTotal = pendingTotalForCombined + approvedTotal + cartTotal;
            
            // Show combined total if there are any totals to show
            if (grandTotal > 0) {
                combinedTotalSection.classList.remove('hidden');
                combinedTotalSection.innerHTML = `
                    <div class="bg-gray-50 rounded-xl p-4 space-y-2">
                        ${pendingTotalForCombined > 0 ? `
                        <div class="flex justify-between items-center text-sm">
                            <span class="text-gray-600">Pending Order:</span>
                            <span class="font-semibold text-orange-600">‚Çπ${pendingTotalForCombined}</span>
                        </div>
                        ` : ''}
                        ${approvedTotal > 0 ? `
                        <div class="flex justify-between items-center text-sm">
                            <span class="text-gray-600">Approved Order:</span>
                            <span class="font-semibold text-green-600">‚Çπ${approvedTotal}</span>
                        </div>
                        ` : ''}
                        ${cartTotal > 0 ? `
                        <div class="flex justify-between items-center text-sm">
                            <span class="text-gray-600">New Items:</span>
                            <span class="font-semibold text-orange-600">‚Çπ${cartTotal}</span>
                        </div>
                        ` : ''}
                        <div class="flex justify-between items-center pt-2 mt-2 border-t border-gray-300">
                            <span class="font-bold text-gray-900 text-base">Grand Total:</span>
                            <span class="font-bold text-gray-900 text-lg">‚Çπ${grandTotal}</span>
                        </div>
                    </div>
                `;
            } else {
                combinedTotalSection.classList.add('hidden');
            }
        }

        window.submitOrder = async () => {
            // ... existing submit order ...
            const btn = document.getElementById('place-order-btn');
            if (Object.keys(state.cart).length === 0) return alert('Cart is empty');
            
            // Prevent submission if pending request exists but not in edit mode
            if (state.pendingRequest && !state.isEditingPendingRequest) {
                return alert('Please use "View / Edit" button to modify your pending order');
            }

            btn.innerHTML = `<div class="w-5 h-5 border-2 border-white rounded-full border-t-transparent animate-spin"></div> Sending...`;
            btn.disabled = true;

            const payload = {
                tenant_id: state.tenantId,
                table_id: state.tableId,
                hall_id: state.hallId,
                items: Object.values(state.cart).map(c => ({
                    item_code: c.item.item_code,
                    name: c.item.name,
                    price: c.item.price,
                    quantity: c.qty,
                    category: c.item.category,
                    is_cgst_applicable: c.item.is_cgst_applicable,
                    is_sgst_applicable: c.item.is_sgst_applicable,
                    group_id: c.item.group_id,
                    group: c.item.group
                })),
                guest_name: document.getElementById('guest-name').value || "Guest",
                guest_phone: document.getElementById('guest-phone').value || ""
            };

            try {
                const res = await axios.post(LAMBDA_URL, payload);
                if (res.data.success) {
                    state.cart = {};
                    state.isEditingPendingRequest = false; // Clear editing flag
                    state.cartModifiedFromPending = false; // Clear modification flag
                    updateCartBarUI();
                    updateMenuQuantitiesOnly(); // Reset quantity buttons
                    closeCart();
                    document.getElementById('confirm-dialog').classList.remove('hidden');
                    document.getElementById('confirm-dialog').classList.add('flex');
                    // Force immediate status check
                    checkTableStatus();
                } else {
                    alert(res.data.message || 'Failed to submit order'); // Improved error msg
                }
            } catch (err) {
                alert('Connection Error');
                console.error(err);
            } finally {
                btn.innerHTML = `<span>Send Order Request</span> <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>`;
                btn.disabled = false;
            }
        };


        window.closeConfirmDialog = () => {
            document.getElementById('confirm-dialog').classList.add('hidden');
            document.getElementById('confirm-dialog').classList.remove('flex');
        };

        window.scrollToActiveItems = () => {
            openCart();
        };

        // Start
        init();

    </script>
</body>

</html>
